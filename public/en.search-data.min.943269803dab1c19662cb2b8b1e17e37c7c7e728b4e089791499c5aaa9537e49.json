[{"id":0,"href":"hashcloak.com/mpcsecurity/docs/threshold_ecdsa_protocols/","title":"Threshold ECDSA protocols","section":"Docs","content":"Threshold ECDSA protocols #  In this series of posts, we will review some of the most relevant works on threshold ECDSA protocols. We present a summary of each work, and after an analysis of the protocols, we include some \u0026ldquo;security concerns\u0026rdquo;, which are points of the protocol to which the auditors and developers need to pay special attention during the revision of an implementation. Those security concerns are extracted from each paper itself, which means that the list does not cover all the possible implementation issues that may arise. Also, for some protocols, we corrected some typos present in the papers to help developers avoid confusion and errors during the implementation process. Finally, we also present some repositories and libraries that implement different threshold ECDSA protocols.\nIntuitively, a threshold signature scheme is a cryptographic functionality that allows a set of $n$ parties to somehow distribute a signing key among them in such a way that only a subset of more than or equal to $t$ parties can sign a message but a subset of less than $t$ parties can do nothing. Such cryptographic primitive has been used actively for key protection in blockchain applications to avoid private key theft and secure financial assets. In this document, we present a summary of some $(t, n)$ signature schemes for the case of $(2, 2)$, $(2, n)$, and the more general case $(t, n)$. This document will contain three main elements of interest: a protocol description for each scheme considered in this work, a list of libraries that implement the protocols, and some security concerns that should be considered at the moment of implementing these protocols.\nThe standalone ECDSA signature scheme #  In order to fully understand the threshold ECDSA protocols, we will revisit first the basics of the ECDSA signature scheme without considering multiple parties, just the standalone cryptographic scheme. First, we need to know that the security of the ECDSA signature scheme relies on the discrete logarithm problem. To explain such problem at a high level, let $\\mathbb{G}$ be a cyclic group with order $q$ and let $G$ be a generator for the group. The discrete logarithm problem relative to $\\mathbb{G}$ and $G$ consist in that, given a random element $R = x \\cdot G$, to find $x \\in \\mathbb{Z}_q$ such that it fulfills the equality. In the literature, the discrete logarithm assumption is that there is a polynomial-time algorithm that generates a group $\\mathbb{G}$ with its order $q$ and generator $G$ such that the discrete logarithm problem is computationally hard. In practice, ECDSA signature schemes use the group of points generated by an elliptic curve.\nNow, let $H: \\{0, 1\\}^* \\rightarrow \\mathbb{Z}_q$ be a hash function (in practice, SHA256 is used). In what follows, let $\\mathbb{G}$ be an elliptic curve group of order $q$ with generator $G$. Let us describe the algorithms for key generation, signing, and verification for the ECDSA signature scheme:\n  $\\textsf{Gen}$: the key generation algorithm works as follows:\n Sample a random element $x \\in \\mathbb{Z}_q$. Compute $X = x \\cdot G$. Output $x$ as the secret key and $X$ as the public key.    $\\textsf{Sign}$: on input $m \\in \\{0, 1\\}^*$ as the message to be signed, and the private key $x \\in \\mathbb{Z}_q$,\n Compute $m\u0026rsquo;$ as the $|q|$ leftmost bits of $H(m)$, where $|q|$ is the bit-length of $q$. Choose a random element $k \\in \\mathbb{Z}_q^*$. Compute $R = k \\cdot G$ and let $R = (r_x, r_y)$. Remember that $R$ is a point over an elliptic curve whose representation is in the cartesian plane. Therefore each point can be represented as a pair. $r = r_x \\mod q$. If $r = 0$ the process returns to Step 2 to select a fresh random $k \\in \\mathbb{Z}_q^*$. Compute $s = k^{-1} \\cdot (m\u0026rsquo; + r \\cdot x) \\mod q$. Output the pair $(r, s)$ as the signature.  It is important to highlight that if $(r, s)$ is a valid signature for a message $m$, then $(r, -s)$ is also a valid signature for this message. Therefore, it is common to choose $\\min\\{s, -s\\}$ in $\\mathbb{Z}_q$ to obtain a unique signature.\n  $\\textsf{Verify}$: On input $(r, s)$ to be the signature and $m \\in \\{0, 1\\}^*$ to be the signed message,\n Compute $m\u0026rsquo;$ as the $|q|$ leftmost bits of $H(m)$. Compute $s^{-1}\\left(m\u0026rsquo; \\cdot G + r \\cdot X\\right)$ and accept if the first component is equal to $r$.    Notice that extracting the first component of a point on the elliptic curve is commonly used here. That can be represented as a function $F: \\mathbb{G} \\rightarrow \\mathbb{Z}_q$, and in the case of ECDSA, it can be defined as $F(x, y) = x \\mod q$. It is important to highlight that when we consider a generic abstract cyclic group, a generic function $H: \\{0, 1\\}^* \\rightarrow \\mathbb{Z}_q$, and a generic function $F: \\mathbb{G} \\rightarrow \\mathbb{Z}_q$, assuming that the discrete logarithm problem and modeling $H$ and $F$ as random oracles, one can prove that such abstract version of the signature scheme is secure. When the ECDSA is instantiated as described in the algorithms $(\\textsf{Gen}, \\textsf{Sign}, \\textsf{Verify})$, is reasonable to model $H$ as a random oracle, but modeling $F$ as a random oracle in this case is not a correct model because $F$ is far from behave as a random function. Despite this, ECDSA has been used and studied and the scrutiny process so far has revealed no significant attack.\nStandalone ECDSA security concerns #   Bad generation and manipulation of $k \\in \\mathbb{Z}_q^*$ in DSA/ECDSA can lead to catastrophic results (see Katz \u0026amp; Lindell, 2014, Section 12.5.2). If the attacker can predict the value of $k$, or if the same $k$ is used twice in two different signature generations, the attacker can obtain the secret key (the latter can occur even if $k$ is unpredictable). The later attack was used to extract the master key on PS3. Let $m \\in \\{0, 1\\}^*$ the message to be signed. Before the process starts, we should compute $m\u0026rsquo;$ to be the $\\vert q \\vert$ leftmost bits of $\\textsf{SHA256}(m)$, where $\\vert q \\vert$ is the bit-length of $q$. This is in fact the message that should be signed, and not $m$ itself (see Lindell, 2021).  Libraries for computing threshold ECDSA #   ZenGo-X/multi-party-ecdsa: written in Rust. It has implementations for Lindell (2021), Genaro \u0026amp; Goldfeder (2019), and Genaro \u0026amp; Goldfeder (2020). cfromknecht/tpec: written in Go. It has implementations for Lindell (2021). neucrypt/mpecdsa: written in Rust. It has implementations for Doerner et al. (2018) and Doerner et al. (2019). sonr-io/kryptology: written in Go. It has implementations for Doerner et al. (2018) and Genaro \u0026amp; Goldfeder (2020). taurusgroup/multi-party-sig: written in Go. Contains an implementation of the protocol proposed by Canetti et al. (2021), also known as CGGMP. boltlabs-inc/tss-ecdsa: written in Rust. Implementation of the protocol proposed by Canetti et al. (2021). coinbase/kryptology: written in Go. Implementations of various protocols. Among them we can find:  Doerner et al. (2018). Gennaro \u0026amp; Goldfeder (2020).   Safeheron/multi-party-ecdsa-cpp: written in C++. Contains implementations of multiple ECDSA protocols. Among them, we can find:  Gennaro \u0026amp; Goldfeder (2019). Gennaro \u0026amp; Goldfeder (2020). Canetti et al. (2021).   webb-tools/cggmp-threshold-ecdsa: written in Rust. Implementation of the threshold ECDSA signature protocol from Canetti et al. (2021) with slight modifications.  References #   Katz, J., \u0026amp; Lindell, Y. (2014). Introduction to Modern Cryptography, Second Edition. Chapman \u0026amp; Hall/CRC. Lindell, Y. (2021). Fast Secure Two-Party ECDSA Signing. Journal of Cryptology, 34(4), 44. doi:10.1007/s00145-021-09409-9.  "},{"id":1,"href":"hashcloak.com/mpcsecurity/docs/threshold_ecdsa_protocols/lindell_2021/","title":"$(2, 2)$ case from Lindell (2021)","section":"Threshold ECDSA protocols","content":"$(2, 2)$ case from Lindell (2021) #  In this case, we will have two parties $P_1$ and $P_2$. Both parties will have a secret key that is secret-shared among them which means that $P_1$ will hold a value $x_1 \\in \\mathbb{Z}_q$ and $P_2$ will hold a value $x_2 \\in \\mathbb{Z}_q$. The idea is to use both pieces of data to compute the signature of a jointly known message. The main difficulty that can be found in this scheme is that for the signature we need the inverse of a random value $k \\in \\mathbb{Z}_q^*$ that is secret-shared among the parties. Concretely, for the signing phase, we need to compute $k^{-1}$ for a value $k \\in \\mathbb{Z}_q^*$ that is shared among the parties ($P_1$ will hold a share $k_1$ and $P_2$ will hold a share $k_2$). This process is very hard considering an additive secret-sharing scheme. For that reason, the work of Lindell (2021) considers a multiplicative secret-sharing scheme, which will allow us to compute this inverse in a more easy way.\nTo completely specify the key generation and signing protocols, they significantly use the Paillier public-key homomorphic encryption scheme. Such encryption scheme will be specified using the traditional triple of algorithms $(\\textsf{Gen}, \\textsf{Enc}, \\textsf{Dec})$. Here, we denote by $\\oplus$ the operation between ciphertexts that produces the encryption of the sum of the underlying clear messages, and similarly, we denote by $\\odot$ the multiplication of ciphertext that obtains the encryption of the product of the underlying messages.\nAdditionally, we first need to describe ideal functionalities for some zero-knowledge proofs used to compute both protocols. Those ideal functionalities are:\n $\\mathcal{F}_{\\textsf{com-zk}}^{R_{DL}}$: This ideal functionality will be defined for testing in the following relation: $$ R_{DL} = \\left\\{\\left(\\mathbb{G}, G, q, P, w \\right) \\;\\vert\\; P = w \\cdot G\\right\\}. $$ Therefore, this zero-knowledge proof will determine if some witness secret value $w$ is the discrete logarithm of a value $P$ relative to a cyclic group $\\mathbb{G}$ with order $q$ described by the generator $G$. Additionally, this functionality will allow one party to commit to values $P$ and $w$ and then decommit such value for the other party to receive $P$ if the proof confirms that $(P, w)$ fulfills the relation relative to the group $\\mathbb{G}$ specified as above. This proof can be instantiated using classic protocols as presented in Schnorr (1989). $\\mathcal{F}_{\\textsf{zk}}^{R_{DL}}$: this functionality has the same zero-knowledge properties as the above functionality but without the commitment section. This proof can be instantiated using the implementation of Schnorr (1989) as above. Proof for $L_P$: we need a zero-knowledge proof to test that a number $N$ is a valid Paillier public key. This can be done by computing a zero-knowledge proof for the following language: $$ L_P = \\left\\{N \\; \\vert \\; \\gcd(N, \\phi(N)) = 1 \\right\\} $$ This proof can be generated as presented in Hazay et al. (2011). Proof for $L_{PDL}$: we need to prove in zero-knowledge that a ciphertext is the encryption of the discrete logarithm of a specified point under a public key $pk$ using the Paillier homomorphic encryption scheme. Concretely, the language for this zero-knowledge proof can be described as follows: $$ L_{PDL} = \\left\\{ \\left(c, pk, Q_1, \\mathbb{G}, G, q \\right) \\; \\vert \\; \\exists (x_1, r), c = \\textsf{Enc}_{pk}(x_1; r) \\; \\text{and} \\; Q_1 = x_1 \\cdot G \\; \\text{and} \\; x_1 \\in \\mathbb{Z}_q \\right\\} $$ An instantiation of this functionality can be found in Lindell (2021), Protocol 6.1.  Key generation #  The idea for the key generation protocol is to consider a coin-tossing protocol to generate a random element $Q$, which in this case will be the public key for the signature scheme. To do this, the party $P_1$ will generate a random element $x_1$. $P_1$ will commit to de value $Q_1 = x_1 \\cdot G$ and will send a zero-knowledge proof of knowledge that $x_1$ is the discrete logarithm of $Q_1$. In a similar way, $P_2$ will generate a random element $x_2 \\in \\mathbb{Z}_q$ and send $Q_2 = x_2 \\cdot G$ along with a zero-knowledge proof of knowledge that $x_2$ is the discrete logarithm of $Q_2$. Then, the goal is to compute $Q = x_1 \\cdot Q_2 = x_2 \\cdot Q_1$ and output it as the public key. $P_1$ and $P_2$ will keep $x_1$ and $x_2$ as multiplicative shares of the secret key.\nA very interesting thing here is that $P_1$ will generate a Paillier key pair $(sk, pk)$, and will compute $c_{key} = \\textsf{Enc}_{pk}(x_1)$ and send it to $P_2$ for further use in the signing protocol.\nSigning #  In this phase, $P_1$ and $P_2$ execute a \u0026ldquo;coin tossing\u0026rdquo; protocol as in the key generation phase to compute a random point $R$ in the elliptic curve in such a way that $P_1$ and $P_2$ hold $k_1$ and $k_2$ respectively, such that $R = k_1 \\cdot k_2 \\cdot G$. Notice that keeping $k_1$ and $k_2$ is of high importance for security. Notice that if some party learns $k_1 \\cdot k_2$, then it could compute the secret key $x$ given a signature of some arbitrary message.\nFor the signing phase, notice that $P_2$ has an encryption of $x_1$ under $P_1$\u0026rsquo;s public key generated by the Paillier encryption scheme. This allows $P_2$ to compute an encryption of $s\u0026rsquo; = k_2^{-1} \\cdot m\u0026rsquo; + k_2^{-1}\\cdot r \\cdot x_1 \\cdot x_2$ under Paillier using the public key of $P_1$, Then $P_1$ can decrypt this value and multiply it for $k_1^{-1}$ to obtain $s\u0026rsquo;\u0026rsquo;$ which is almost the signature. Then, the party computes the signature as $s = \\min\\{s\u0026rsquo;\u0026rsquo;, q - s\u0026rsquo;\u0026rsquo;\\}$ to ensure that the parties are choosing the smallest value possible for the signature. Something interesting here is that $P_1$ can verify the validity of the signature under public key $Q$ because, as we specified before, the protocol allows each party to individually verify signatures using the public key.\nNote that in this work, they are mixing the ECDSA signature scheme with the Paillier encryption scheme. This mixture needs additional consideration given the difference in the modulus reduction because ECDSA computes reductions modulo $q$ but Paillier computes reductions modulo $N^2$, which do not necessarily match, and such reductions affect the security of each method. Therefore, when we use Paillier, we need to mask the underlying plaintext in such a way that the decryption does not reveal any information. That is the role of $\\rho \\cdot q$ in $P_2$\u0026rsquo;s second message. The idea is to mask the value of $k_2^{-1} \\cdot m\u0026rsquo; + k_2^{-1} \\cdot r \\cdot x_2 \\cdot x_1$ with a random-looking value, namely $\\rho \\cdot q$, in such a way that when this the masked value is reduced modulo $q$ the mask is removed.\nSecurity concerns #   The inadequate handling of abort signals as specified by the protocol can allow an adversary to recover the private signing key. The details of the attack can be found here. Also, Makriyannis \u0026amp; Yomtov (2023) show a vulnerability associated with poor abort handling. In the key generation:  Check the length of Paillier keys to be correct (see Protocol 3.1 from Lindel, 2021). $P_2$ should verify and execute all the ZK-proofs [List all the ZK-proofs in detail]. In the distributed signing, $P_2$ can compute a value $s\u0026rsquo; = k_2^{-1} \\cdot m\u0026rsquo; + k_2^{-1} \\cdot r \\cdot x_2 \\cdot x_1$ using Pallier homomorphic properties to obtain a ciphertext of it. Then $P_2$ can send this ciphertext to $P_1$ but the decryption of such value can reveal information to $P_1$ because $s\u0026rsquo;$ does not have a reduction modulo $q$. Remember that the modulus in Paillier may be different from the modulus used in ECDSA. To prevent this, $P_2$ must add $\\rho \\cdot q$ inside the encryption for a $\\rho$ taken at random. In Lindell, 2021, they suggest to choose $\\rho \\stackrel{R}{\\leftarrow} \\mathbb{Z}_{q^2}$. $P_2$ may send a incorrect $s\u0026rsquo;$. Therefore, $P_1$ must check that the signature is correct. However, $P_2$ could adversarially choose $s\u0026rsquo;$ so that $P_1$ accepts or rejects the signature $s = k_1^{-1} \\cdot s\u0026rsquo;$ given a condition on $x_1$ known to $P_2$. In that case, $P_2$ can extract information about $x_1$.   In the signing protocol:  $P_1$ and $P_2$ check if the session ID $sid$ has not been used before. If it happens, the protocols shouldn\u0026rsquo;t be executed. Execute all the ZK-proofs in the signing protocol [List all the ZK-proofs in detail]. In $P_2$\u0026rsquo;s second message, it should veryfy that $\\gcd(\\tilde{r}, N) = 1$. Check that the signature $s = \\min\\{s\u0026rsquo;\u0026rsquo;, q - s\u0026rsquo;\u0026rsquo;\\}$. Remember that for a signature $(r, s)$, $(r, -s)$ is also a valid signature. To compute the signature correctly, the $N$ choosen for Paillier must hold $N \u0026gt; q^3 + q^2$.    ZK-proofs #  In the key generation #   In $P_1$\u0026rsquo;s first message, Literal (b), the party $P_1$ sends a commitment on $Q_1$ and a proof of knowledge of its discrete logarithm as specified in the relation $R_{\\textsf{DL}}$. In $P_2$\u0026rsquo;s first message, Literal (c), the party $P_2$ sends a proof of knowledge of the discrete logarithm of $Q_2$ as specified in the relation $R_{\\textsf{DL}}$. In the step ZK-proofs, $P_1$ proves to $P_2$ in zero-knowledge that $N$ belongs to the language $L_P$ (i.e. the Paillier key was generated correctly) and that the tuple $(c_{key}, pk, Q_1)$ belongs to the language $L_{PDL}$.  In the signing protocol #   In $P_1$\u0026rsquo;s first message, Literal (b), the party $P_1$ sends a commitment to $R_1$ and a proof of knowledge of its discrete logarithm to $P_2$ according to the relation $R_{\\textsf{DL}}$. In $P_2$\u0026rsquo;s first message, Literal (c), the party $P_2$ sends a ZK-proof of knowledge of the discrete logarithm of $R_2$.  References #   Lindell, Y. (2021). Fast Secure Two-Party ECDSA Signing. Journal of Cryptology, 34(4), 44. doi:10.1007/s00145-021-09409-9 Schnorr, C. P. (1990). Efficient Identification and Signatures for Smart Cards. In G. Brassard (Ed.), Advances in Cryptology \u0026mdash; CRYPTO’ 89 Proceedings (pp. 239–252). New York, NY: Springer New York. Nikolaos Makriyannis, \u0026amp; Oren Yomtov. (2023). Practical Key-Extraction Attacks in Leading MPC Wallets. Hazay, C., Mikkelsen, G. L., Rabin, T., \u0026amp; Toft, T. (2012). Efficient RSA Key Generation and Threshold Paillier in the Two-Party Setting. In O. Dunkelman (Ed.), Topics in Cryptology \u0026ndash; CT-RSA 2012 (pp. 313–331). Berlin, Heidelberg: Springer Berlin Heidelberg.  "},{"id":2,"href":"hashcloak.com/mpcsecurity/docs/threshold_ecdsa_protocols/doerner_et_al_2018/","title":"$(2, n)$ case from Doerner et al. (2018)","section":"Threshold ECDSA protocols","content":"$(2, n)$ case from Doerner et al. (2018) #  The protocol proposed by Doerner et al. (2018) presents a threshold ECDSA protocol with a threshold of $2$-out-of-$n$. This means that from a set of $n$ parties, whatever two parties from this set can generate a signature. This protocol has two different versions. The most recent version aims to correct some issues found in the first version which improves the quality of the cryptographic assumptions and corrects some errors. Those issues will be covered here as concerns given that it may happen that some organizations have an implementation of the older version which needs corrections in an audit process.\nFirst, we start to show the newest version of the protocol. The parties interact with other three ideal functionalities:\n $\\mathcal{F}_{\\textsf{CP}}^{\\mathcal{R}_\\textsf{DL}}$: this functionality is the standard committed zero-knowledge functionality which allows committing to the exponent of an elliptic curve point, and also performs a zero-knowledge proof on the relation $\\mathcal{R}_\\textsf{DL} = \\left\\{(A, B, w ) \\;\\vert\\; B = w \\cdot A \\right\\}.$ $\\mathcal{F}_{\\textsf{Mul}}(q)$: in this functionality, two parties provide elements $a, b \\in \\mathbb{Z}_q$ respectively. and the functionality computes $d = a \\cdot b - c$ where $c$ is a random element chosen from $\\mathbb{Z}_q$. At the end of the protocol, one party learns $d$ and the other party learns $c$. Intuitively, $\\mathcal{F}_{\\textsf{Mul}}(q)$ returns to each party an additive share of the product of the inputs they provided to the functionality, i.e., $d$ and $c$ are randomly distributed numbers such that $d + c = a \\cdot b$. $\\mathcal{F}_{\\textsf{DLKeyGen}}(\\mathcal{G}, n, 2)$: this is a functionality that generates a key pair $(\\textsf{sk}, \\textsf{pk})$ for the ECDSA signature scheme and distributes Shamir shares of $\\textsf{sk}$ with threshold $t$.  We next present the functionalities mentioned above:\nNow, we present the protocol that realizes the functionality $\\mathcal{F}_\\textsf{ECDSA-2P}(\\mathcal{G}, n)$ presented in the original paper, which is the main functionality. In this specification, $\\textsf{RO}$ is a non-programmable global random oracle.\nWe stress that this protocol has multiple versions and people were able to implement an older version of it containing errors or assumptions that are not well studied. We encourage the reader to refer to the section about concerns below to be informed about possible modifications.\nAll we have left is a protocol that realizes the $\\mathcal{F}_\\textsf{Mult}$ functionality. Remember that this functionality takes two elements $\\alpha, \\beta \\in \\mathbb{Z}_q$ and returns additive shares of their product $\\alpha \\cdot \\beta$. This functionality allows one of the parties to introduce a noise to the multiplication which models the capabilities of a malicious adversary. According to the paper, such adversarial behavior is then detected in the signature verification in the broader context of the signature protocol.\nNow, we will present the multiplication protocol. This protocol corresponds to the older version of the paper, therefore they use the KOS OT method to realize the correlated oblivious transfer extension $\\mathcal{F}_\\textsf{COTe}^\\mathcal{l}$. Remember that the use of the original protocol must be deprecated and replaced by a secure realization of the functionality.The specification of this functionality is shown next:\nThe multiplication protocol is similar to the classic Gilboa OT multiplication, however, this method is vulnerable to selective failure attacks in a malicious setting. To correct this, Doerner et al. (2018) encode Bob\u0026rsquo;s input with some redundancy in a way such that learning $s$ of Bob\u0026rsquo;s choice bits via selective failure does not leak any information about the input value. The encoding works as follows:\nHere, $\\mathbf{g}^\\textsf{R} \\in \\mathbb{Z}_q^{\\kappa + 2s}$ is a random vector. Now we present the multiplication protocol:\nSecurity concerns #  As we have mentioned above, this protocol has multiple versions. So it is of high importance to check which implementation is going to be audited always suggesting to include the more recent one due to the improvements made. Here, we will present some of such concerns:\n The original paper of this implementation has some errors that were corrected in the current version of the protocol. This older version has been implemented and deployed by some organizations. Therefore, from an audit point of view, it is important to check which version is being implemented. The original scheme in this work realizes a non-standard two-party functionality that allows one party to negibly bias the distribution of the instance key. This fact is not a serious concern as the bias is negligible and they gave proof of security, which gives more confidence to realize a standard functionality. Deprecate the use of Keller et al. (2015) for OT extension protocols given that Roy (2022) have found some gaps in the proof. The older version of the paper has some typos in the reproduction of the OT protocol taken from Keller et al. (2020). The original version of the paper left some details about how to deal with aborts when functionality has multiple sub-sessions being executed concurrently. In the case of correlated oblivious transfer extensions (COTe) and multiplication functionalities, one must check that if a sub-session aborts, then the other concurrent sub-subsessions being executed must abort too. This also must be transferred to the ECDSA signing protocol in which multiple multiplication functionalities are executed concurrently: an abort in any instance of the multiplication protocol executed by some pair of parties must cause an abort in all the signing sub-sessions in which the parties are involved and prevent them from signing together again. The original proof contains an optimized \u0026ldquo;coalesced triple-multiplication in which no proof of security is presented. The authors strongly recommend not to use such implementation in the future until a proof of security is provided. The newest version of the protocol assumes that all of the parties in any protocol are fully connected using authenticated channels. The newest version of the protocol does not include a specification of what to do in the first step of the setup when there exists a record $(\\textsf{key-pair}, \\textsf{sid}, \\textsf{pk}, p(i))$. In Step 2 of the setup protocol, if the key generation protocol aborts, the parties send an abort signal to the environment. We need to check if there is an initialization process in the protocol used to realize the functionality $\\mathcal{F}_\\textsf{Mul}(q)$. If the initialization is required, Step 3 in the Setup phase is a good place to compute it. In the Signing phase, Step 7, we need to check if the conditions imposed on the records do not hold, the signing message from the environment must be ignored. In the Signing phase, Step 8, the authors do not introduce what is $\\textsf{RO}$. But in the proof you can find that $\\textsf{RO}$ is a non-programable global random oracle. We need to check that in the real implementation, there is a proper instantiation of it. The newest version of the paper contains additional steps in the $\\pi_\\textsf{ECDSA-2P}$ protocol, namely, Steps 4-6 which is a commitment to the Alice\u0026rsquo;s share of a random element in the elliptic curve. We should check that the commitment is performed. Bob needs to check if the resulting signature $\\sigma$ is a valid signature with respect to the message $m$ before outputting it. In the protocol for multiplication $\\pi_\\textsf{Mul}$, Bob must need to perform the checking in Step 6. The paper sugests to use SHA-256 to instantiate the random oracle $H$. Also, they use this hash function to instantiate the PRG.  ZK-proofs #   In Step 5 of the Two-Party ECDSA protocol, Alice commits to the value of $r_\\textsf{A}$. In Step 10, Alice proofs the commitment of $r_\\textsf{A}$ and proves in zero-knowledge that she knows $r_\\textsf{A}$ such that is the discrete logarithm of $D_\\textsf{A}$. Notice that this protocol not only proves the above fact in zero-knowledge but also sends the commitment of $r_\\textsf{A}$ to Bob.  References #   Doerner, J., Kondi, Y., Lee, E., \u0026amp; Shelat, A. (2018). Secure Two-party Threshold ECDSA from ECDSA Assumptions. In 2018 IEEE Symposium on Security and Privacy (SP) (pp. 980-997). Keller, P. (2015). Actively Secure OT Extension with Optimal Overhead. In Advances in Cryptology – CRYPTO 2015 (pp. 724–741). Springer Berlin Heidelberg. Lawrence Roy (2022). SoftSpokenOT: Quieter OT Extension from Small-Field Silent VOLE in the Minicrypt Model. In Advances in Cryptology - CRYPTO 2022 - 42nd Annual International Cryptology Conference, CRYPTO 2022, Santa Barbara, CA, USA, August 15-18, 2022, Proceedings, Part I (pp. 657–687). Springer.  "},{"id":3,"href":"hashcloak.com/mpcsecurity/docs/threshold_ecdsa_protocols/canetti_et_al_2021/","title":"$(t, n)$ case from Canetti et al. (2021)","section":"Threshold ECDSA protocols","content":"$(t, n)$ case from Canetti et al. (2021) #  In this work, Canetti et al. present a protocol for Threshold ECDSA signatures with the following characteristics:\n Only the last round of the protocol needs knowledge of the message to be signed. Therefore, all the previous rounds can be executed in a preprocessing stage. The protocol supports adaptative corruption in the signing phase. In this case, the authors provide a mechanism to refresh the auxiliary information and keys used in the signing phase to provide security against an attacker that corrupts a different set of parties over time. The protocol realizes an ideal threshold signing functionality in the UC framework. The protocol achieves identifiable abort in the signing process.  The above characteristics make this protocol compatible with solutions that use cold wallets in cryptocurrencies given that the protocols are non-interactive (i.e. only the last round requires the knowledge of the message to be signed). To allow a non-interactive signing phase, there is a process of pre-signing which can be computed without any knowledge of the message. The parties engage in a protocol $L$ times in a concurrent way to obtain pre-signing data for $L$ signatures. Once the message is known, the parties retrieve one tuple of the generated pre-signing data and use it to generate a signature. Then, the parties erase the pre-signing information once it is used.\nThe signing protocol can be divided into two phases: a preprocessing phase in which the keys and the required auxiliary information are established, and a non-interactive phase in which the parties locally retrieve the information needed to construct the signature and locally compute a share of it.\nIt is important to mention that this work only focuses on the $n$-out-of-$n$ signature case and it does not cover the case of $t$-out-of-$n$ explicitly. However, to obtain a protocol for the latter case, the protocol can be easily modified using Shamir secret-sharing as presented in Gennaro \u0026amp; Goldfeder (2020).\nPreliminaries #  As in previous works about threshold ECDSA, this work also uses the Paillier encryption scheme extensively. Also, it uses some zero-knowledge proofs to guarantee a correct execution in the presence of malicious adversaries. The ZK-proofs used in this work will be presented in the next section along with a strategy to compile $\\Sigma$-protocols into a non-interactive version using a random oracle via the Fiat-Shamir heuristic.\nA concept that appears in this protocol different from its predecessor is the proactive security. Although threshold signature protocols bring additional security for digital signatures, they may still be vulnerable to an attacker who can corrupt a set of parties that change over time. According to Canetti et al., in a proactive threshold signature scheme, the time is divided into epochs, such that at the end of each epoch, the parties engage in a protocol to refresh all the information needed to generate a signature (i.e. keys, local state, and random values). If the protocol is proactive, it remains secure as long as at most $t - 1$ players are compromised within a single epoch. Therefore, if the set of compromised parties changes from one epoch to the next, the protocol remains secure as long as the number of parties is within the threshold.\nNP-relations #  In this section, we present the NP-relations that will be used in the protocol to determine whether the protocol has been executed correctly or not by using ZK-proofs.\nZK-Module #  Now, we present the strategy used by Canetti et al. to compile a $\\Sigma$-protocol into a non-interactive version using the Fiat-Shamir heuristic. Aside from the standard prove and verify operations. This module contains a commit operation to output the first message $A$ of the ZK-proof, which is useful in security analysis. The ZK-Module is presented next.\nProtocol description #  In this section, we present the threshold ECDSA signing into two versions: the first one will be an online signing, and the second one will be a non-interactive signing. Those protocols use the key generation, the key and auxiliary information refresh, and the signing process as building blocks that will be covered in the next sections.\nKey generation #  Briefly speaking about the key generation protocol, each party $P_i$ samples a random element $x_i \\stackrel{R}{\\leftarrow} \\mathbb{F}_q$ which will be an additive share of the secret key $x = \\sum_{i=1}^n x_i$ and then reveals the value of $X_i = g^{x_i}$. Notice that $X = \\prod_{i=1}^n X_i = g^x$ is the public key associated to $x$. By using ZK-proofs and commitments, the parties guarantee the consistency of $X_i$.\nKey refresh and auxiliary information #  In the key refresh and auxiliary information phase, each party $P_i$ generates a fresh Paillier modulus $N_i$ and ring-Pedersen parameters $(s_i, t_i)$. Also, each party $P_i$ generates additive shares of zero $(x_i^1, \\dots, x_i^n)$ such that $\\sum_{j=1}^n x_i^j = 0$ and then computes the vector of group elements $\\mathbf{X}_i = (X_i^1 = g^{x_i^1}, \\cdots, X_i^n = g^{x_i^n})$. Then the party $P_i$ sends all the elements $N_i, s_i, t_i, \\mathbf{X}_i$ to all the other parties. After obtaining all the values from other parties, each party encrypts $x_i^j$ under the Paillier encryption scheme using the public key $N_j$ to obtain the value $C_i^j$ for $j \\neq i$, and then, $P_i$ sends to $P_j$ the encrypted value.\nOnce each party receives the information sent above, they re-compute the shares of the secret key as $x_i^* = x_i + \\sum_{j=1}^n x_j^i \\mod q$, and update the group elements to be consistent with the new secret key shares by doing $X_i^* = X_i \\cdot \\prod_j X_j^i$. Also, each party stores the Paillier modulus and Pedersen parameters $(N_1, s_1, t_1), \\dots, (N_n, s_n, t_n)$.\nThroughout the execution of the protocol, the parties use ZK-proofs to guarantee the consistency of the values. For example, the parties use such proofs to check that the Paillier keys and Pedersen parameters are well-formed and to check that the values of $X_i^j$ are consistent with the values of $x_i^j$.\nNext, we present a detailed specification of the protocol taken from the paper of Canetti et al.\nThree-round presignin with $O(n^2)$ identification cost #  Remember that one of the main contributions of the work of Canetti et al. is to propose a non-interactive protocol for signing. This means that all the rounds but the last one do not need the knowledge of the message to be executed. The rounds preceding the construction of the signature are called pre-signing. Here, we show a version of the presigning phase that has three rounds, and it can identify the corrupt parties with a cost of $O(n^2)$.\nThe pre-signing protocol of Canetti et al. uses similar techniques presented in the signing protocol of Gennaro \u0026amp; Goldfeder (2020). Specifically, in both works, they use the concept of transforming multiplicative shares into additive shares using the Paillier encryption scheme. This technique allows the parties to compute additive shares of a masked version of $k$ and also it allows them to find additive shares of $k \\cdot x$, where $k$ is the nonce used in the signing process. At the end of the signing protocol, the parties will obtain shares $(R, k_i, \\chi_i)$, where $k_i$ is an additive share of the nonce $k$, $\\chi_i$ is a share of $k \\cdot x$ and $R = g^{k^{-1}}$.\nOne of the advantages of this protocol is that the parties can engage in $L$ concurrent sessions to generate tuples $\\left \\{ (l, R_l, k_{i, l}, \\chi_{i, l}) \\right \\}_{i=1}^L$ as the pre-signing material for $L$ signatures. The parties can store these tuples in the local memory and they extract a fresh tuple once the message to be signed is known. However, it is important to ensure that the parties erase the pre-signing tuples that were already used to avoid security vulnerabilities.\nWe present a detailed specification of the protocol next, which is taken from the paper of Canetti et al.\nSigning #  Once the pre-signing phase has been executed, parties have shares $(R, k_i, \\chi_i)$ in their local memory. Therefore, once the parties know the hash of the message $m$ to be signed, they can retrieve a pre-signing tuple $(R, k_i, \\chi_i)$, then compute $r = R \\vert_{x-\\text{axis}}$, and locally compute an additive share of the signature $\\sigma_i = k_i \\cdot m + r \\cdot \\chi_i \\mod q$. Then, each party broadcasts the additive share $\\sigma_i$ to the rest of the parties to reconstruct the signature $(r, \\sigma)$. It is important to remember that the parties must erase the used pre-signing tuples.\nSix-round presigning with $O(n)$ identification cost #  In their paper, Canetti et al. present an alternative to compute the presignin phase that takes six rounds but it has a linear identification cost, contrary to the previous version where the presigning takes three rounds but a quadratic identification cost. The differences between this version concerning the previous one can be highlighted in two points: (1) the parties publish the values of $\\Gamma_i = g^{\\gamma_i}$ after the computation of $\\delta = k \\cdot \\gamma$, and (2) the parties commit the share $\\chi_i$ using an Elgamal fashion to generate a pseudo-key $S_i = R^{\\chi_i}$ to identify the corrupt parties in an abort. Next, we present the protocol specification taken from the paper of Canetti et al.\nIdentification process #  In this version of the protocol, the abort can be produced in two points: (1) when $g^\\delta \\neq \\prod_i \\delta_i$ in Round 6, and (2) when $\\prod S_i \\neq X$ in Round 7. The difficulty here is that if one of those checks does not pass, it is not immediate which of the parties produced the fault. To solve this, depending on the fault point, the parties are instructed to reveal in zero-knowledge the plaintext values of $K_i$ and $\\{ D_{i,j} \\}$ and the power of $\\Gamma_i$ for the fault point (1), and the plaintext values of $K_i$ and $\\{ \\hat{D}_{i,j} \\}$ and the secret hidden by $\\mathbf{Z}_i$ for the fault point (2). With these values, the parties now can identify who is the party that produced the fault. For more details, we present the specification of the identification process for both points in the following protocols taken from the paper of Canetti et al.\nSigning #  Once the hash $m$ of the message is known, the parties retrieve a tuple $(l, R, \\{ \\bar{R}_j, S_j \\}_j, k_i, \\chi_i)$ coming from the presignin phase and stored in the local memory. Then, the parties compute a share of the signature by calculating $r = R \\vert_{x-\\text{axis}}$ and then they set $\\sigma_i = k_i \\cdot m + r \\cdot \\chi_i \\mod q$. Each party broadcasts its share $\\sigma_i$, and when the party has the shares of the other parties, the party checks that $R^{\\sigma_j} = \\bar{R}_j^m \\cdot S_j^r$ for all $j \\neq i$. If all checks pass, then the party returns $\\left (r, \\sum \\sigma_i \\right )$ as the signature. Next, we present all the details of the signing protocol taken from the paper of Canetti et al.\n$\\Sigma$-protocols #  In this section, we present some of the underlying $\\Sigma$-protocols used to provide security against malicious adversaries. Similar to the paper of Canetti et al., we exclude the protocols for those NP-relations that are similar to the ones presented here or they are Schnorr-based proofs. For more details about the remaining protocols, we refer the reader to Appendix C. in the paper of Canetti et al. Remember that all the relations used in this review are presented in the list of relations presented in a previous section.\nPaillier encryption in range #  This protocol is the $\\Sigma$-protocol for the relatin $R_{\\textsf{enc}}$. In this case, the input of the protocol for tuples of the form $(\\mathcal{I}, C; k, r_0)$, where $\\mathcal{I} = \\{-2^l, \\dots, 0, \\dots, 2^l\\}$ (remember that this set is denoted as $\\pm 2^l$). The Prover want to convince the Verifier that he knows $k \\in \\pm 2^l$ , such that $C = (1 + N_0)^k \\cdot r_0^{N_0} \\mod N_0^2$. Next, we will present the details of the protocol taken from the paper of Canetti et al.\nPaillier operation with group commitment in range #  This $\\Sigma$-protocol executes on tuples of the form $(\\mathcal{I}, \\mathcal{J}, C, Y, X; x, y, k, r_0)$ where $\\mathcal{I} = \\pm 2^l$ and $\\mathcal{J} = \\pm 2^{l\u0026rsquo;}$ satisfying the relation $R_{\\textsf{aff-g}}$. In this proof, the Prover tries to convince the Verifier that he knows $x \\in \\pm 2^{l}$ and $y \\in \\pm 2^{l\u0026rsquo;}$ such that $X = g^x$ and $Y = \\textsf{enc}_{N_1}(y) \\in \\mathbb{Z}_{N_1^2}$ under the Paillier encryption scheme, and $C, D \\in \\mathbb{Z}_{N_0^2}$ such that $D = C^x (1 + N_0)^y \\cdot \\rho^{N_0} \\mod N_0^2$, for some $\\rho \\in \\mathbb{Z}_{N_0}^*$.\nPaillier-Blum modulus in zero-knowledge #  Now, we show a $\\Sigma$-protocol for tuples of the form $(N; p, q)$ satisfying the relation $R_\\textsf{mod}$. In this case, the Prover wants to convince the Verifier that $N$ is a Paillier-Blum modulus. This means that the Prover knows a pair of prime numbers $(p, q)$ such that $N = pq$ and satisfying that $p, q \\equiv 3 \\mod 4$.\nRing-Pedersen parameters in zero-knowledge #  Here, we present a $Sigma$ protocol for tuples of the form $(N, s, t; \\lambda)$ for the relation $R_\\textsf{prm}$. In this proof, the Proover wants to convince the Verifier that he knows a power $\\lambda$ for which $s = t^\\lambda$, or equivalently, the Proover wants to convince the verifier that $s$ belongs to the multiplicative group generated by $t$. Next, we present the protocol for this proof taken from Canetti et al.\nSecurity concerns #   The security of the protocol relies on the following assumptions: strong RSA, DDH, semantic security of the Paillier encryption scheme, and an enhanced variant of the existencial unforgeability of ECDSA. The protocol assumes that the signatories are connected using an authenticated and synchronous broadcast mechanism. The use of an authenticated communication channel is essential to obtain proactive security and synchronous broadcast mechanisms are essential for accountability. Whenever a NIZK fails for some party, the remaining parties identify such party as the culprit and report it as corrupted. It is important to make sure that, as part of the refresh stage to guarantee proactivity, any unused tuples computed in the presigning phase need to be discarded. Remember that this protocol focuses on the case of $n$-out-of-$n$ for the signing phase, however, this work can be extended to the case of $t$-out-of-$n$ using similar techniques to Gennaro \u0026amp; Goldfeder (2020) by using verifiable Shamir secret-sharing schemes. However, we need to be careful at the moment of using preprocessing data. In this case, each set of authorized parties needs to generate independent preprocessing data. Also, we need to make sure that if a party engages in a signature protocol with different authorized sets, he/she must not use the same preprocessed data between authorized sets. It is important to ensure that the parties are not signing two different messages using the same preprocessed data. These actions can enable attackers to reveal the private signing key. In the protocol, the parties need to use some ZK-proofs that require setup parameters. Given that the protocol does not assume any trusted setup, the parties need to compute these setup parameters themselves. Specifically, as stated in Section 2.3, the setup parameter is generated by the Verifier along with a ZK-proof to check that the setup parameters are well formed. In the notation of the ZK-Module, the authors often omit the randomness in the tuple, but in any case, we need to sample fresh randomness. In Figure 3 where it is presented the online signing, the parties need to erase all the presigning and auxiliar information once the key refresh is executed. Also, the parties need to reset the $ssid$ to a new one consistent with the new presigning information. In Figure 4 for the Presigning stage, the party $P_i$ needs to erase all presigning data for the session id $sid$.  For the key generation #   In Round 3, Step 1, of the Key generation protocol, the parties need to verify that querying the random oracle with the first message of the ZK-proof matches with the value sent by the parties. In the Output phase, Step 1, the parties need to verify that the first message of the received proof coincides with the committed first message of the proof constructed in the first round. In case of a failing verification, the parties need to report the corrupt party and halt.  For the key refresh and auxiliary information #   In Round 3, Step 1, each party $P_i$ needs to verify that the $N_j$ received from party $P_j$ fulfills the condition $N_j \\geq 2^{8\\kappa}$ and that $\\prod_k X_j^k = \\textsf{id}_{\\mathbb{G}}$ (the identity of the group $\\mathbb{G})$. In Round 3, Step 1, each party $P_i$ needs to verify that the information received from Round 2 when evaluated into the random oracle matches with the commitment constructed and sent in Round 1 ($V_j$) for each other party $P_j$. In the Output phase, the party $P_i$ needs to compute the following checks:  Verify that $g^{x_j^i} = X_j^i$. If this equality does not hold, $P_i$ computes $\\mu = (C_j^i \\cdot (1 + N_i)^{x_j^i})^{1/N}$. Then, the party broadcasts $(P_j, C_j^i, x^i_j, \\mu)$ and halts. Verify that the first message of the proof $\\pi_j$ coincides with the commitment of the first message ($B_j$) obtained as a result of the first round. Verify that the first message of the Schnorr proof obtained from the first round ($A_j^k$) coincides with the first message of the proof $\\psi_j^k$.   When there is a failure in some verification or the \u0026ldquo;Dec Error\u0026rdquo; is received, the party needs to report the culprit and halt.  For the three-round version #  Presigning #   In the Output phase, the parties need to verify that $g^\\delta = \\prod_j \\Delta_j$. If this equality does not hold, the parties need to execute the steps presented in Step 2 of the Output phase. If there is an error in some NIZK, the parties must report the party that induced the failure and then halt.  Signing #   In Round 1, the parties need to erase the presigning tuple used once the signature share is computed and broadcasted. In the Output phase, the parties need to verify that the constructed signature is a valid signature using the standalone version of the $\\textsf{Verify}$ algorithm. If there is an error in some NIZK, the parties must report the party that induced the failure and then halt.  For the six-round version #  Presigning #   In the Round 6, Step 2, the parties need to verify that $g^\\delta = \\prod_j \\Delta_j$. If this equality does not hold, the parties execute the steps proposed in the \u0026ldquo;red alert #1\u0026rdquo;. In the Output phase, Step 2, the parties need to verify that $\\prod S_k = X$. If this equality does not hold, the parties execute the steps presented in the \u0026ldquo;red alert #2\u0026rdquo;. If any NIZK fails, the parties report the culprit and halt. If the failure occurs and directs the parties to some red alert, the step of the corresponding alert must be executed.  Identification process #  For red alert #1 #  In the Output phase, we need to check the following equalities:\n Check that $K_j = (1 + N_j)^{k_j} \\tilde{\\rho}_j \\mod N_j^2$. Check that $D_{j,k} = (1 + N_j)^{\\alpha_{j, k}} \\tilde{\\mu}_{j,k} \\mod N_j^2$, for $k \\neq j$. Check that $g^{\\gamma_j} = \\Gamma_j$ and $\\delta_j = k_j \\gamma_j + \\sum_{l \\neq j} (\\alpha_{j, l} + k_l \\gamma_j - \\alpha_{l, j}) \\mod q$.  If any of the previous checks fails, the party detecting the failure reports the corrupt party according to the check computed.\nIn this protocol, there are two typos in Round 1:\n In the first proof, the correct instruction would be $\\psi_{i} = \\mathcal{M}(\\texttt{prove}, \\Pi^{\\textsf{Nth}}, (ssid, i), (N_i, \\rho_{i}^{N_i}), \\rho_{i})$. In the second proof, the correct instruction would be $\\psi_{i, j} = \\mathcal{M}(\\texttt{prove}, \\Pi^{\\textsf{Nth}}, (ssid, i), (N_i, \\mu_{i,j}^{N_i}), \\mu_{i, j})$, for $j \\neq i$.  For red alert #2 #   Check that $K_j = (1 + N_j)^{k_j} \\tilde{\\rho}_j \\mod N_j^2$. Check that $D_{j,k} = (1 + N_j)^{\\alpha_{j, k}} \\tilde{\\mu}_{j,k} \\mod N_j^2$, for $k \\neq j$. check that $\\tilde{Y}_j^{-1} M_j = X_j^{k_j} \\cdot \\prod_{l \\neq j} (g^{\\hat{\\alpha}_{j,l}} \\cdot X^{k_l}_j \\cdot g^{-\\hat{\\alpha}_{l,j}})$.  If any of the previous checks fails, the party detecting the failure reports the corrupt party according to the check computed.\nIn this protocol, there are the following typos in Round 1:\n In the first proof, the correct instruction would be $\\psi\u0026rsquo;_i = \\mathcal{M}(\\texttt{prove}, \\Pi^{\\textsf{log}}, (ssid, i), (g^{b_i}, Y_i, \\tilde{Y}_i; b_i)$. In the second proof, the correct instruction would be $\\psi_{i} = \\mathcal{M}(\\texttt{prove}, \\Pi^{\\textsf{Nth}}, (ssid, i), (N_i, \\rho_{i}^{N_i}), \\rho_{i})$. In the third proof, the correct instruction would be $\\psi_{i, j} = \\mathcal{M}(\\texttt{prove}, \\Pi^{\\textsf{Nth}}, (ssid, i), (N_i, \\hat{\\mu}_{i,j}^{N_i}), \\hat{\\mu}_{i, j})$, for $j \\neq i$.  Signing #   In the Output phase, the parties need to verify that the final signature is a valid signature using the algorithm $\\textsf{Verify}$ from the standalone ECDSA signature scheme. If this check fails, the party $P_i$ checks that $R^{\\sigma_j} = \\bar{R}_j^m \\cdot S^r_j$, for all $j \\neq i$. If some verification of the item above fails for some $j \\neq i$, then, the party $P_i$ reports the party $P_j$ as the culprint. Once the signature is obtained and the checks are computed, the parties delete the corresponding presigning tuple used to construct the signature from the memory.  ZK-proofs and commitments #   In the ECDSA Key-Generation protocol, the party $P_i$ performs the following proofs and commitments:  In Round 1, the party commits to the first value of a $\\Pi^\\textsf{sch}$ proof. In Round 4, the party proves in ZK that $x_i$ such that it is the discrete logarithm of $X_i$.   In the Auxiliary Info. and Key Refresh protocol, the party $P_i$ computes the following proofs and commitments:  In Round 1, the party commits to the first message $B_i$ of the $\\Pi^\\textsf{sch}$ protocol. In Round 1, the party proves that he knows $\\lambda$ such that $s_i = t_i^\\lambda \\mod N_i$. In Round 1, the party commits to the first message $A_i^j$ of the $\\Pi^\\textsf{sch}$ protocol. In Round 3, the party proves in zero-knowledge that the tuple $(N_i; p_i, q_i)$ belongs to the $R_\\textsf{mod}$ relation. In Round 3, the party proves in zero-knowledge that he knows $p_i, q_i \u0026gt; 2^\\kappa$, such that $N_i = p_i q_i$. In Round 3, the party proves in zero-knowledge that he knows the discrete logarithm of $X_i^j.$ In Round 3, the party proves in zero-knowledge that he knows the discrete logarithm of $Y_i$.    For the three-round version #   In the Pre-signing protocol, the party $P_i$ executes the following ZK-proofs and commitments:  In Round 1, the party proves that the plaintext value of the ciphertext $K_i$ is in the range $\\mathcal{I}_\\epsilon$. In Round 2, the party proves in zero-knowledge that the tuple $(\\mathcal{I}_\\epsilon, \\mathcal{J}_\\epsilon, D_{j, i}, K_j, F_{j,i}, \\Gamma_i; \\gamma_i, \\beta_{i,j}, s_{i,j}, r_{i,j})$ belongs to the relation $R_\\textsf{aff-g}$. In Round 2, the party proves in zero-knowledge that the tuple $(\\mathcal{I}_\\epsilon, \\mathcal{J}_\\epsilon, \\hat{D}_{j, i}, K_j, \\hat{F}_{j,i}, X_i; x_i, \\hat{\\beta}_{i,j}, \\hat{s}_{i,j}, \\hat{r}_{i,j})$ belongs to the relation $R_\\textsf{aff-g}$. In Round 2, the party proves in zero-knowledge that the tuple $(\\mathcal{I}_{\\epsilon}, G_i, \\Gamma_i, g; \\gamma_i, \\nu_i)$ belongs to the relation $R_{\\textsf{log} \\ast}$. In Round 3, Step 2, the party proves in zero-knowledge that $(\\mathcal{I}_{\\epsilon}, K_i, \\Delta_i, \\Gamma; k_i, \\rho_i)$ belongs to the relation $R_{\\textsf{log} \\ast}$. In the Output phase, Step 2(a), the party reproves that $\\{ D_{j, i} \\}$ are well-formed according to the relation $R_\\textsf{aff-p}$. In the Output phase, Step 2(b), the party proves in ZK that $H_i$ is well formed with respect to $K_i$ and $G_i$ according to the relation $R_\\textsf{mul}$. In the Ouptut phase, Step 2(c), the party proves in ZK that $\\delta_i$ is the plaintext value mod $q$ obtained from the equation $H_i \\cdot \\prod_{j \\neq i} D_{i,j} \\cdot F_{i,j}$.   In the Signing protocol, the party $P_i$ executes the following ZK-proofs and commitments:  In the Output phase, Step 2(a), the party reproves that $\\{ \\hat{D}_{j, i} \\}$ are well-formed according to the relation $R_\\textsf{aff-p}$. In the Output phase, Step 2(b), the party proves in ZK that $\\hat{H}_i$ is well formed with respect to $K_i$ and $X_i$ according to the relation $R_\\textsf{mul}$. In the Ouptut phase, Step 2(c), the party proves in ZK that $\\delta_i$ is the plaintext value mod $q$ obtained from the equation $K_i^m \\cdot \\left ( \\hat{H}_i \\cdot \\prod_{j \\neq i} \\hat{D}_{i,j} \\cdot \\hat{F}_{i,j} \\right )^r$.    For the six-round version #   In the Pre-signing phase the party $P_i$ executes the following proofs:  The party proves that the tuple $(\\mathcal{I}_\\epsilon, K_i, Y_i, \\mathbb{Z}; k_i, \\rho_i, b_i)$ belong to the relation $R_\\textsf{enc-elg}$, for all $j \\neq i$. In Round 2, the party proves in zero-knowledge that the tuple $(\\mathcal{I}_\\epsilon, \\mathcal{J}_\\epsilon, D_{j, i}, K_j, F_{j,i}, G_i; \\gamma_i, \\beta_{i,j}, s_{i,j}, r_{i,j}, \\nu_i)$ belongs to the relation $R_\\textsf{aff-p}$. In Round 2, the party proves in zero-knowledge that the tuple $(\\mathcal{I}_\\epsilon, \\mathcal{J}_\\epsilon, \\hat{D}_{j, i}, K_j, \\hat{F}_{j,i}, X_i; x_i, \\hat{\\beta}_{i,j}, \\hat{s}_{i,j}, \\hat{r}_{i,j})$ belongs to the relation $R_\\textsf{aff-g}$. In Round 4, the party proves that the tuple $(\\mathcal{I}_\\epsilon, G_i, \\Gamma_i, g; \\gamma_i, \\nu_i)$ belongs to the relation $R_{\\textsf{log} \\ast}$. In Round 5, Step 2, the party proves that the tuple $(Y_i, \\mathbb{Z}_i, \\Delta_i, \\Gamma; k_i, b_i)$ belongs to the relation $R_\\textsf{elog}$. In Round 6, Step 2, the party proves that the tuple $(Y_i, \\hat{\\mathbf{Z}}_i, S_i, R; \\chi_i, \\lambda_i)$ belongs to the relation $R_\\textsf{elog}$.   In the Nonce-Reveal Fail, the party $P_i$ executes the following ZK-proofs:  In Round 1, the party proves that the tuple $(N_i, \\rho_i^{N_i}; \\rho_i)$ belongs to the relation $R_\\textsf{Nth}$. In Round 1, the party proves that the tuple $(N_i, \\mu_{i,j}^{N_i}; \\mu_{i, j})$ belongs to the relation $R_\\textsf{Nth}$.   In the Pseudo-Key Reveal Fail, the party $P_i$ executes the following ZK-proofs:  In Round 1, the party proves that the tuple $(g^{b_i}, Y_i, \\tilde{Y}_i; b_i)$ belongs to the relation $R_\\textsf{log}$. In Round 1, the party proves that the tuple $(N_i, \\rho_i^{N_i}; \\rho_i)$ is in the relation $R_\\textsf{Nth}$. In Round 1, the party proves that the tuple $(N_i, \\hat{\\mu}_{i,j}^{N_i}; \\hat{\\mu}_{i,j})$, for $j \\neq i$.    References #   Canetti, R., Gennaro, R., Goldfeder, S., Makriyannis, N., \u0026amp; Peled, U. (2020). UC Non-Interactive, Proactive, Threshold ECDSA with Identifiable Aborts. Proceedings of the 2020 ACM SIGSAC Conference on Computer and Communications Security, 1769–1787. https://doi.org/10.1145/3372297.3423367 Rosario Gennaro, \u0026amp; Steven Goldfeder. (2020). One Round Threshold ECDSA with Identifiable Abort.  "},{"id":4,"href":"hashcloak.com/mpcsecurity/docs/threshold_ecdsa_protocols/doerner_et_al_2019/","title":"$(t, n)$ case from Doerner et al. (2019)","section":"Threshold ECDSA protocols","content":"$(t, n)$ case from Doerner et al. (2019) #  In this work, Doerner et al. continue to improve the previous version of the protocol presented in Doerner et al. (2018) and generalize it to the arbitrary threshold case $(2, n)$. They prove the security of their protocol under CDH assumption in the Global Random Oracle model. At the end of the work, they propose a series of experiments showing that their solution is practical even when using low-power devices.\nThe protocol has a setup phase that is an extension of the work of Doerner et al. (2018). In this setup, the parties obtain a Shamir secret-share of $\\textsf{sk}$ with threshold $t - 1$. This means that $t$ parties can join efforts to reconstruct $\\textsf{sk}$. The Shamir shares allow $t$ parties to obtain an additive share of $\\textsf{sk}$ using the Lagrange multiplies consistent with the Shamir secret-sharing scheme.\nThe signing protocol is performed between a set of $\\mathbf{P} \\subseteq [n]$ parties with $\\vert \\mathbf{P} \\vert = t$. This phase is comprised of three parts:\n  Multiplication and inversion. Here the parties involved in the signing protocol use a $t$ party inverse protocol to obtain additive shares of $k$, $1/k$ and the value $R = k \\cdot G$, where $k$ is sampled at random from $\\mathbb{Z}_q$. Then, they use a multiplication protocol to compute additive shares of $\\textsf{sk}/k$ using the additive shares of $1/k$ and $\\textsf{sk}$ as input.\n  Consistency check. In this phase, the parties use public values like $\\textsf{pk}$ and $R = k \\cdot G$ to check the consistency of the values generated in the previous phase.\n  Signing. Once the parties have finished with the checking phase, they will end up with shares $v_i$ and $w_i$ such that:\n $\\sum_{i \\in \\mathbf{P}} v_i = 1/k$. $\\sum_{i \\in \\mathbf{P}} w_i = \\textsf{sk} / k$.  Then, parties will compute shares of the signature $\\textsf{sig}_i = v_i \\cdot H(m) + w_i \\cdot r_x$. Finally, they can reconstruct the signature by computing $\\textsf{sig} = \\sum_{i \\in \\mathbf{P}} \\textsf{sig}_i$.\n  Preliminaries #  The ECDSA signing protocol relies on two ideal functionalities already discussed in previous works. The first one is $\\mathcal{F}_\\textsf{Com}^n$ which is a commit functionality among $n$ parties. The second functionality involved is $\\mathcal{F}_\\textsf{Com-ZK}^{R_\\textsf{DL}, n}$ which is a ZKPoK of discrete logarithms. The third functionality is a correlated oblivious transfer extension functionality which has been mentioned in the work of Doerner et al. (2018) in the previous section. Again, this COTe functionality is realized using the work of KOS OT whose original version has an incorrect proof of security. Therefore, it is better to choose other alternatives for this, for example SoftSpokenOT by Lawrence Roy (2022).\nTwo-party multiplication #  First, we describe a protocol for a two-party multiplication. This functionality, called $\\mathcal{F}_\\textsf{2PMul}^l$, takes an input vector $\\mathbf{a} \\in \\mathbb{Z}_q^l$ from Alice and an input vector $\\mathbf{b} \\in \\mathbb{Z}_q^l$ from Bob, and it computes two vectors $\\mathbf{z}_\\textsf{A}, \\mathbf{z}_\\textsf{B} \\in \\mathbb{Z}_q^l$ such that ${\\mathbf{z}_\\textsf{A}}_i + {\\mathbf{z}_\\textsf{B}}_i = \\mathbf{a}_i \\cdot \\mathbf{b}_i$. The funcitonality sends $\\mathbf{z}_\\textsf{A}$ to Alice and $\\mathbf{z}_\\textsf{A}$. Intuitively, the functionality takes a batch of numbers from both sides and computes additive two-party shares of the product of each component in the batch. The full specification of this functionality can be found in Doerner et al. (2019).\nThe protocol that realizes this functionality is the following:\nModular inverses #  Now, we describe a protocol that allows $t$ parties to obtain shares of a random number and its modular inverse along with its product with the generator of the elliptic curve. The ideal functionality associated with this protocol is called $\\mathcal{F}_\\textsf{Inv}^{n, t}$. The protocol interacts with multiple instances of the $\\mathcal{F}_\\textsf{2PMul}^l$ functionality presented above. More specifically, the party $\\mathcal{P}_i$ will obtain additive shares $u_i$, $v_i$ and a value $R$ such that: $\\sum_{i \\in \\mathbf{P}} u_i = k$, $\\sum_{i \\in \\mathbf{P}} v_i = 1/k$ and $R = k \\cdot G$.\nIn this protocol, the parties sample multiplicative shares of $k$ and a random value $\\phi$, and then they compute multiplicative shares of $\\phi / k$ locally. Then, these multiplicative shares are converted into additive shares of $\\phi / k$. At the end of the protocol, the parties perform a consistency check to confirm that both the additive shares and multiplicative shares are related in the correct way, and then they reconstruct the value of $\\phi$ to transform the shares of $\\phi / k$ into shares of $1/k$.\nWe now present the protocol specification according to Doerner et al.\nSigning protocol #  With the preliminaries established, we can present the protocol for threshold ECDSA. Doerner et al. present this protocol in two phases: a setup phase and a signing phase.\nIn the setup phase, the parties generate Shamir secret-shares of the private key $\\textsf{sk}$ with threshold $t$. Then each party can locally generate a $t$-party additive share using the appropriate Lagrange multipliers. The novel strategy in this protocol relies on each party confirming if all possible subsets of $t$ consecutive parties have sent to him/her consistent shares of $\\textsf{sk}$ with respect to $\\textsf{pk}$ by checking the relation homomorphically in the elliptic curve group as we will see in Step 6 of the protocol. This will not reveal the key $\\textsf{sk}$ because it will be hidden all the time \u0026ldquo;in the exponent\u0026rdquo;. We present the setup protocol next:\nOnce the $n$ parties have completed the setup phase, any group $\\mathbf{P}$ of $t$ parties can get involved in the signing phase by inputting the message $m$, the public key $\\textsf{pk}$ and the share $p(i)$ of $\\textsf{sk}$ obtained in the setup phase. At the end of the signing phase, each party in $\\mathbf{P}$ obtains a copy of the signature $\\sigma$. The protocol of the signing phase is presented next:\nSecurity concerns #   The ECDSA functionality aborts if any party tries to reuse the same session ID, send a message out of order, etc. We need to check that the implementation also considers this case, and we also need to be more specific in which cases the functionality aborts. The functionalities presented here have aborts that are session global. This means that when a misbehavior produces an abort, all further commands with the same session ID are rejected. In Section 2.3, Paragraph 1, the authors say that $\\mathcal{F}_\\textsf{Com-ZK}^{R_\\textsf{DL}, n}$ allows a party to send a commitment to both an elliptic curve point and a proof of knowledge of its discrete logarithm to a group of parties, and then reveal both. For an inexpert programmer, this can be confusing in the sense that this functionality only reveals the commitment point in the elliptic curve and it does not reveal the associated discrete logarithm. Deprecate the use of Keller et al. (2015) for OT extension protocols given that Roy (2022) have found some gaps in the proof. Functionality $\\mathcal{F}_\\textsf{2PMul}^l$ has two typos. In \u0026ldquo;Alice\u0026rsquo;s input\u0026rdquo; phase it needs to check that $\\mathbf{a} \\in \\mathbb{Z}_q^l$ instead of $\\mathbb{Z}_q$, and the same occurs in \u0026ldquo;Bob\u0026rsquo;s input\u0026rdquo; for $\\mathbf{b}$. In the multiplication protocol we need to make sure that parties perform the consistency check in Step 6. Although the third round of protocol $\\pi_\\textsf{2PMul}^l$ is not necessary for the protocol, it is necessary for the proof of security. There are cases in which an adversary can compromise the random multiplication. In the protocol $\\pi_\\textsf{Inv}^{n, t}$, Step 6, the order in which the parties interact matters. In this case, if the party that plays the role of Alice goes second, we need to consider a Rushing Alice phase when we are executing the protocol that realizes $\\mathcal{F}_\\textsf{2PMul}^l$. We need to check if the consistency checks in Steps 6-10 are correctly executed. In the ECDSA protocol, we need to check what hash function is being used. The standard specifies that this function should be SHA-256. We need to check that the consistency check in the ECDSA Setup protocol presented in Step 6 is computed correctly. We need to check that the consistency check in the ECDSA Signing protocol presented in Steps 5-7 is computed. At the end of the signing protocol, each party should verify that the signature is correct by using the $\\textsf{Verify}$ algorithm in the ECDSA standalone version.  ZK-proofs and commitments: #   In the protocol $\\pi_\\textsf{Inv}^{n, t}$, Step 2, each party $P_i$ in the subset of parties commites to the value of $\\phi_i$. In the protocol $\\pi_\\textsf{Inv}^{n, t}$, in the Consistency Check, Step 6, each party $P_i$ commits to the value of $R_i$. In the protocol $\\pi_\\textsf{Inv}^{n, t}$, in the Consistency Check, Step 7, each party $P_i$ commits to the value of $\\Gamma_i^1$. In the protocol $\\pi_\\textsf{ECDSA-Setup}^{n, t}$, Step 4, each party $P_i$ commits and proofs in zero-knowledge that $p(i)$ is the discrete logarithm of $T_i$. In the protocol $\\pi_\\textsf{ECDSA-Sign}^{n, t}$, Step 5 of the Consistency Check, each party $P_i$ commits to the tuple $(\\Gamma_i^2, \\Gamma_i^3)$.  References #   Doerner, J., Kondi, Y., Lee, E., \u0026amp; Shelat, A. (2019). Threshold ECDSA from ECDSA Assumptions: The Multiparty Case. In 2019 IEEE Symposium on Security and Privacy (SP) (pp. 1051-1066). Keller, P. (2015). Actively Secure OT Extension with Optimal Overhead. In Advances in Cryptology – CRYPTO 2015 (pp. 724–741). Springer Berlin Heidelberg. Lawrence Roy (2022). SoftSpokenOT: Quieter OT Extension from Small-Field Silent VOLE in the Minicrypt Model. In Advances in Cryptology - CRYPTO 2022 - 42nd Annual International Cryptology Conference, CRYPTO 2022, Santa Barbara, CA, USA, August 15-18, 2022, Proceedings, Part I (pp. 657–687). Springer.  "},{"id":5,"href":"hashcloak.com/mpcsecurity/docs/threshold_ecdsa_protocols/doerner_et_al_2023/","title":"$(t, n)$ case from Doerner et al. (2023)","section":"Threshold ECDSA protocols","content":"$(t, n)$ case from Doerner et al. (2023) #  Preliminaries #  In this work, Doerner et al. present a $t$-out-of-$n$ threshold ECDSA signature protocol that fully subsumes the works of Doerner et al. (2018) and Doerner et al. (2019). This work realizes a standard ECDSA signature functionality in three rounds with statistical security instead of computational security as in the works of Doerner et al. (2018) and Doerner et al. (2019). There in this section, we will use the notation used by Doerner et al. (2018).\nThis work is based on ECDSA tuples which are tuples of the form $(\\phi, r, u, v)$, such that $r$ is the secret pre-signature instance key, $u = r \\cdot \\phi$ and $v = \\phi \\cdot \\textsf{sk}$. Notice that an ECDSA signature is of the form\n$$ s = \\frac{a + \\textsf{sk} \\cdot b}{r}, $$\nwhere $a$ and $b$ are publicly known values. Therefore, if we have secret shares of an ECDSA tuple $(\\phi, r, u, v)$, we can make public $w = a \\cdot \\phi + b \\cdot v$ and $u$ to obtain $s = w / u$. Notice that if the secret sharing is linear, then $w$ can be computed locally and the signature assembling will take just one round coming from reconstructing $w$ and $u$.\nThe work of Doerner et al. (2023) focuses on constructing the ECDSA tuples and checking that such tuple is consistent with the public key $\\textsf{pk}$ and the value $R = r \\cdot G$ generated in the signing process. This is done by using pairwise statistical consistency checks from Doerner et al. (2019). Also, the generation of ECDSA tuples is done by using pairwise oblivious linear evaluation (VOLE).\nThe protocol uses the functionality $\\mathcal{F}_\\textsf{DLKeyGen}(\\mathcal{G}, n, t)$ to generate Shamir shares of keys for discrete logarithm cryptosystems. This functionality was presented in the previous section of this document, and we refer to the reader there. The protocol also relies on a standard commitment functionality $\\mathcal{F}_\\textsf{Com}$.\nThe protocol uses a functionality to sample uniform secret-shares of zero in a non-interactive way, which can be realized in the $\\mathcal{F}_\\textsf{Com}$-hybrid random oracle model. Next, we present the functionality for distributing shares of zero.\nFinally, to realize the ECDSA functionality, the authors make use of a random vector oblivious linear functionality denoted by $\\mathcal{F}_\\textsf{RVOLE}(q, \\mathcal{l})$. In this functionality, the first party (Bob) to invoke the functionality receives a single random value. Then, the other party (Alice) inputs a vector of chosen values. The output of the functionality will be additive shares of the product of the random value sent to Bob with each element of the vector provided by Alice. Here, we will present the functionality taken from Doerner et al. (2023). However, there is a typo in such specification. In The Multiplication step, the functionality computes $\\mathbf{d}_i = \\mathbf{a}_i \\cdot b - \\mathbf{c}_i$. The value of $b$ does not have any sub-index.\nThe basic three-round protocol #  First, let us show an intuition of the protocol. Suppose that each party $\\mathcal{P}_i$ has knowledge of additive shares $r_i$ and $\\textsf{sk}_i$ for $r$ and $\\textsf{sk}$. Also, suppose that $\\mathcal{P}_i$ samples a random uniform mask $\\phi_i$. Suppose also they know $u_i$ and $v_i$ such that\n$$ \\sum_{i \\in \\mathbf{P}} u_i = \\sum_{i \\in \\mathbf{P}} r_i \\cdot \\sum_{i \\in \\mathbf{P}} \\phi_i, $$\nand\n$$ \\sum_{i \\in \\mathbf{P}} v_i = \\sum_{i \\in \\mathbf{P}} \\textsf{sk}_i \\cdot \\sum_{i \\in \\mathbf{P}} \\phi_i. $$\nHaving these ingredients, we can compute a valid signature for $m$ under $\\textsf{pk} = \\textsf{sk} \\cdot G$ and $R = r \\cdot G$ by doing\n$$ \\frac{\\sum_{i \\in \\mathbf{P}} \\left( \\textsf{SHA}(m) \\cdot \\phi_i + r^\\textsf{x} \\cdot v_i \\right)}{\\sum_{i \\in \\mathbf{P}} u_i} = \\frac{\\textsf{SHA}(m) + r^\\textsf{x} \\cdot \\textsf{sk}}{r}. $$\nThe only thing that we have left is to check that $\\textsf{pk} = \\textsf{sk} \\cdot G$ and $R = r \\cdot G$ were consistently generated and that any party added any offset in the middle of the process. The latter concern can be addressed by testing that the final signature is a valid signature for the message $m$ by verifying the signature as in the standalone ECDSA. For the latter, the authors propose an additional check as follows. Suppose that $\\mathcal{P}_i$ has $\\mathbf{c}_{i, j}^\\textsf{u}$ and $\\mathbf{c}_{i, j}^\\textsf{v}$, and each party $\\mathcal{P}_j$ has $\\mathbf{d}_{j, i}^\\textsf{u}$ and $\\mathbf{d}_{j, i}^\\textsf{v}$ such that $\\mathbf{c}_{i, j}^\\textsf{u} = r_i \\cdot \\phi_j - \\mathbf{d}_{j, i}^\\textsf{u}$ and $\\mathbf{c}_{i, j}^\\textsf{v} = \\textsf{sk}_i \\cdot \\phi_j - \\mathbf{d}_{j, i}^\\textsf{v}$. Having this correlations, $\\mathcal{P}_i$ sends $R_i = r_i \\cdot G$ and $\\textsf{pk}_i = \\textsf{sk}_i \\cdot G$, and then send values $\\mathbf{\\Gamma}_{i, j}^\\textsf{u} = \\mathbf{c}_{i, j}^\\textsf{u} \\cdot G$ and $\\mathbf{\\Gamma}_{i, j}^\\textsf{v} = \\mathbf{c}_{i, j}^\\textsf{v} \\cdot G$ to authenticate the values of $R_i$ and $\\textsf{pk}_i$ by verifying the equality $\\mathbf{\\Gamma}_{i, j}^\\textsf{u} = R_i \\cdot \\phi_j - \\mathbf{d}_{i, j}^\\textsf{u} \\cdot G$. Notice that the probability that this equality holds when $\\mathcal{P}_i$ sending $R_i \\neq r_i \\cdot G$ is negligible in $\\kappa$. A similar check can be performed by $\\mathcal{P}_j$.\nNext, we present the three-round protocol.\nAccording to the authors, this protocol can be improved using pipelining and preprocessing. On the one hand, pipelining refers to the fact that the first round of the protocol can be computed before the message $m$ is known. This allows a set of parties to sign a bunch of messages together to evaluate the first round of one signing instance simultaneously with the last round of the previous signing instance. Such improvement reduces the number of rounds to two in the overall process. On the other hand, preprocessing allows the first two rounds of the protocol to be evaluated before the message is known, leaving the last round as the only one to be evaluated online. However, using preprocessing has some conditions to be fulfilled that lead to new potential attack vectors. The authors recommend using the preprocessing only when the technique is fully understood and accepting the implications and risks that it has.\nAs mentioned before, this work subsumes the work of Doerner et al. (2018) which is a $2$-out-of-$n$ threshold signature scheme. The protocol presented in this work can be modified to reach the same communication properties as its predecessor. Those modifications are equivalent to a rushing behavior and in this case, the protocol is secure because it was proven secure against rushing adversaries.\nIt is also important to highlight that when the corrupted parties are strictly less than $t/2$, the protocol can be modified to take advantage of techniques like replicated secret-sharing schemes which improve the bandwidth and round complexity.\nSecurity concerns #   The authors suggest realizing the multiplication functionality using a refinement of the protocol of Doerner et al. (2019). The protocol assumes that the parties are fully connected using authenticated channels. So we need to check how this condition is fulfilled. The functionality for ECDSA threshold signing makes a formal difference between all the possible aborts. We need to check that the aborts fulfill all the conditions stated in the protocol specification. The protocol to realize the RVOLE functionality has an initialization phase that is not present in the paper. Therefore, it is imperative to check that this initialization phase is done securely. The authors mention that the protocol of Haitner et al. 2023 can be used to realize a weaker version of the RVOLE functionality. However, the authors have not proven the use of such functionality to be secure in combination with the protocol they propose. In Step 8 the parties need to check the equalities to check that the shares of $R$ and $\\textsf{pk}$ were used honestly. If the checks of Step 8 do not hold or the RVOLE functionality aborts between $\\mathcal{P}_i$ and $\\mathcal{P}_j$, $P_i$ must send a failure message to all other parties and also sends an analogous message at the corresponding point in all concurrent signing sessions that involve $\\mathcal{P}_j$. Also, the party sends a failure message to the environment, does not continue with Step 10, and does not participate in any future signing session with $\\mathcal{P}_j$. It is needed to check how the last fact is ensured in a real-world implementation. In the last step of the signing phase, the party verifies that the produced signature is a valid signature using the standalone version of the ECDSA signature scheme. If the protocol uses preprocessing, it is necessary that all the conditions in which preprocessing can be applied are met. Also, we must be sure that the client of an audit agrees with the implications and risks associated with preprocessing.  Commitments #  In the protocol $\\pi_\\textsf{ECDSA}$, Step 6, each party $P_i$ commits to the value of $R_i$.\nReferences #   Jack Doerner, Yashvanth Kondi, Eysa Lee, \u0026amp; abhi shelat. (2019). Threshold ECDSA from ECDSA Assumptions: The Multiparty Case.  "},{"id":6,"href":"hashcloak.com/mpcsecurity/docs/threshold_ecdsa_protocols/gennaro_goldfeder_2019/","title":"$(t, n)$ case from Gennaro \u0026 Goldfeder (2019)","section":"Threshold ECDSA protocols","content":"$(t, n)$ case from Gennaro \u0026amp; Goldfeder (2019) #  Important note: This paper has some corrections addressing errors and wrong conjectures from the first version. Although we will point out such errors, it is important to make sure that the implementation meets the updated version of the protocol.\nNote on notation: Different from the previous works presented in this document, this work uses multiplicative notation for groups.\nIn this work, Genaro \u0026amp; Goldfeder propose a new method for a $(t, n)$ signature scheme. However, we have to keep in mind that when they say $(t, n)$, they mean that any subset of $t + 1$ parties can jointly sign but any smaller set cannot, which is slightly different from the concept presented in other works reviewed in this document. Also, this work focuses on the DSA signature scheme but the results can be easily applied to ECDSA as the latter is an elliptic curve variant of the former. Genaro \u0026amp; Goldfeder propose a solution based on the Paillier encryption scheme to realize a functionality that transforms multiplicative shares into additive ones, along with non-malleable equivocable commitments to ensure a correct computation against malicious adversaries. Also, he uses Feldman\u0026rsquo;s verifiable secret-sharing scheme (VSS) to ensure the threshold security of the signing process.\nPreliminaries #  In this section, we present three definitions to understand the signing protocol by Gennaro \u0026amp; Goldfeder. First, we will explain what is a non-malleable equivocable commitment. Second, we will explain the specification of the DSA signature scheme. And third, we will explain the concept of Feldman\u0026rsquo;s VSS.\nDSA signature scheme #  The Digital Signature Algorithm (DSA) is a signature scheme whose security relies on the discrete logarithm problem. The public paramenters of this scheme are a cyclic group $\\mathcal{G}$ with order $q$, a generator $g$ for $\\mathcal{G}$, a hash function $H: \\{0, 1\\}^* \\rightarrow \\mathbb{Z}_q$, and a hash function $H\u0026rsquo;: \\mathcal{G} \\rightarrow \\mathbb{Z}_q$. The specifications of the algorithms are presented next:\n $\\textsf{KeyGen}$: on input a security parameter, the algorithm outputs a secret key $x$ chosen at random from $\\mathbb{Z}_q$, and also outputs a public key $y = g^x$ in $\\mathcal{G}$. $\\textsf{Sign}$: On input a message $M$, do the following:  Compute $m = H(M)$. Choose $k \\in \\mathbb{Z}_q$ at random. Compute $R = g^{k^{-1}}$ in $\\mathcal{G}$ and $r = H\u0026rsquo;(R)$ in $\\mathbb{Z}_q$. Compute $s = k(m + x \\cdot r) \\mod q$. Output $\\sigma = (r, s)$.   $\\textsf{Ver}$: on input $M$, $\\sigma$ and $y$, do:  Compute $m = H(M)$. Check that $r, s \\in \\mathbb{Z}_q$. Compute $R\u0026rsquo; = g^{(ms^{-1} \\mod q)}y^{(rs^{-1} \\mod q)}$ Accept if $H\u0026rsquo;(R\u0026rsquo;) = r$.    We stress that ECDSA is a particular case of DSA where the group $\\mathcal{G}$ is an elliptic curve group. For this work, all the results presented also hold for ECDSA.\nShare conversion protocol #  The goal of the share conversion protocol is to transform multiplicative into additive shares of a secret. Specifically, suppose that $x = ab \\mod q$ where $a, b \\in \\mathbb{Z}_q$ are the multiplicative shares held by Alice and Bob respectively. Using a share conversion protocol, Alice and Bob will compute $\\alpha, \\beta \\in \\mathbb{Z}_q$ such that $\\alpha + \\beta = x = ab \\mod q$. In the end, Alice will hold bot $\\alpha$ and $a$, while Bob will hold $\\beta$ and $b$.\nFor this version of the protocol, we assume that Alice has distributed a key $A$ for an additively homomorphic scheme $\\mathcal{E}$ over an integer $N$. In the protocol, we assume that $B = g^b$ is public to force Bob to provide a correct $b$. This protocol (including the additional check) is denoted as $\\textsf{MtAwc}$ (\u0026ldquo;multiplicative to additive with check\u0026rdquo;). The protocol without this check is denoted by $\\textsf{MtA}$. We present the protocol next:\nNon-malleable equivocable commitments #  A trapdoor commitment scheme is a commitment that is information-theoretic hiding and computationally binding, whereas, for the latter, the scheme admits a trapdoor such that when known, it reveals the commited message entirely. However, this trapdoor is hard to compute efficiently.\nA trapdoor commitment scheme consists in four algorithms $\\textsf{KG}$, $\\textsf{Com}$, $\\textsf{Ver}$, $\\textsf{Equiv}$ such that:\n $\\textsf{KG}$ is the algorithm for key generation which outputs a pair $(\\textsf{pk}, \\textsf{tk})$, where $\\textsf{pk}$ is the public-key associated with the commitment scheme and $\\textsf{tk}$ is the trapdoor key. $\\textsf{Com}$ is the commitment algorithm. On input $\\textsf{pk}$ and a message $M$, it outputs $[C(M), D(M)] = \\textsf{Com}(\\textsf{pk}, M, R)$ where $R$ are the coin toses. $C(M)$ is the commitment string, while $D(M)$ is the decommitment string. The latter is kept secret until the opening time. $\\textsf{Ver}$ is the verification algorithm. On input $C$, $D$ and $\\textsf{pk}$, it either outputs a message $M$ or $\\bot$. $\\textsf{Equiv}$ is the algorithm that opens a commitment in every possible way given the trapdoor string. On input $\\textsf{pk}$, stringgs $M$, $R$ such that $[C(M), D(M)] = \\textsf{Com}(\\textsf{pk}, M, R)$, a message $M\u0026rsquo; \\neq M$ and a string $T$. if $T = \\textsf{tk}$, then $\\textsf{Equiv}$ will output $D\u0026rsquo;$ such that $\\textsf{Ver}(\\textsf{pk}, C(M), D\u0026rsquo;) = M\u0026rsquo;$.  In real-world applications, it is common to use a hash function $H$ to instantiate these commitments. For a message $m$, we define the commitment as $h = H(m, r)$ where $r$ is randomly chosen with a length equal to the security parameter $\\lambda$.\nFeldman\u0026rsquo;s VSS #  Feldman\u0026rsquo;s VSS is an extension of Shamir\u0026rsquo;s secret-sharing scheme. To share a secret $\\sigma \\in \\mathbb{Z}_q$, the dealer generates a random polynomial $p$ such that $p(0) = \\sigma$. This means that the polynomial has the following structure:\n$$ p(x) = \\sigma + a_1 x + a_2 x^2 + \\cdots + a_t x^t \\mod q. $$\nAs in Shamir\u0026rsquo;s secret-sharing, each party $P_i$ receives $\\sigma_i = p(i) \\mod q$ as a share of the secret value $\\sigma$. The extension comes in place when the dealer of the secret also publishes $v_i = g^{a_i}$ in the group $\\mathcal{G}$ for all $i \\in [t]$, and $v_0 = g^\\sigma$. With this modification, each party $P_i$ can check the consistency of each share $\\sigma_i$ by checking the equality\n$$ g^{\\sigma_i} \\stackrel{?}{=} \\prod_{j=0}^t v_j^{i^j} $$\nin $\\mathcal{G}$. In the case that some party complains about the check, the protocol must abort.\nKey generation #  The goal of the key generation is to obtain $(t, n)$ shares of the private key that will be used as input in the signing phase. For this specification, we assume that each party $P_i$ has an associated public key for the additively homomorphic encryption scheme $\\mathcal{E}$. Below, present the protocol:\nSigning #  Now, we present the signing protocol. It receives $m = H(M)$ as input, where $M$ is the message that will be signed. Additionally, the parties have $(t, n)$ shares of the private key $x$.\nLet $S \\subseteq [n]$ be the set of parties involved in the signing protocol, such that $\\vert S \\vert = t + 1$. Knowing that the key generation protocol returned Shamir shares of the private key $x$, each party can construct the appropriate Lagrange coefficients $\\lambda_{i, S}$ used to interpolate the polynomial used in the secret-sharing scheme. If $x_i$ are the Shamir secret shares of $x$, each party can compute $w_i = \\lambda_{i, S} \\cdot x_i$. Notice that $w_i$ is a (t, t + 1) share of $x$ held by the party $P_i$, which means that $x = \\sum_{i \\in S} w_i$. Also, the parties have public values $X_i = g^{x_i}$, therefore, each party can compute $W_i = g^{w_i} = X_i^{\\lambda_{i, S}}$.\nNotice that in Step (5B) of the previous protocol, the party $P$ broadcasts $V = R^s g^l$ and $A = g^\\rho$ and he needs to prove that he knows $s$, $l$ and $\\rho$ for which the previous equations hold. To prove that he knows $\\rho$, it can be used a classic Schnorr proof. To prove that he know $s$ and $l$, they can use the following protocol:\nSecurity concerns #   In the paper, Gennaro \u0026amp; Goldfeder say that the last version of the paper has some fixes in the protocol and its proofs of security for which the previous version is not correct. Therefore, it is important to double-check which version of the protocol has been implemented. At the end of the signing protocol, the parties need to verify that the produced signature is valid using the standalone version of the verify algorithm in the DSA/ECDSA signature scheme. The previous version of the protocol did not check the range of the values encrypted with the Paillier encryption scheme which produces a leak of information about honest parties\u0026rsquo; shares. Works like Tymokhanov \u0026amp; Shlomovits (2021) and Makriyannis \u0026amp; Peled (2021) have shown that removing the ZK-proofs lead into an insecure protocol. Therefore, it is important to check that all the proofs are correctly executed. The protocol assumes the existence of a broadcast channel as well as point-to-point channels connecting every pair of players. In this case, we need to check that these conditions are correctly realized. There is a small typo in the non-malleable equivocable commitment in the $\\textsf{Com}$ algorithm where they say \u0026ldquo;where $r$ is the coin tosses\u0026rdquo;, but the correct version is \u0026ldquo;where $R$ is the coin tosses\u0026rdquo;. The authors say that non-malleable commitments that are not \u0026ldquo;concurrently\u0026rdquo; secure are not suitable for the protocol. Instead, an implementation should consider a concurrent secure non-malleable commitment scheme. It is necessary to check that whenever Feldman\u0026rsquo;s VSS protocol complains about a bad check-in of the shares, the protocol will abort. The authors recommend that, in a typical choice of parameters, $N$ is approximately $q^8$. Also, they stress that the parties should check the size of N to ensure the ZK property in the proofs. It is important to remember that the message to be signed is $m = H(M)$ and not $M$ itself. In the signing protocol there are a series of checks that need to be computed, specifically, in Steps 5B, 5D, and 5E. The paper presents Section 5 as a historical record, however, the simplified protocol presented in that section is not secure. If the implementation uses another additively homomorphic encryption scheme, it requires an assumption analogous to Paillier-EC or a ZK-proof for the statement in the $\\textsf{MtAwc}$ protocol. Also, it is needed to guarantee security against \u0026ldquo;adversarially chosen\u0026rdquo; public keys. In the Signature generation protocol, Phase 5, Step (5C), there is a typo: the player proves in ZK that $A_i = g^{\\rho_i}$.  ZK-proofs #   In the $\\textsf{MtAwc}$ protocol, Step 1, Alice needs to prove in ZK that she knows $a \u0026lt; q^3$ using a range proof. In the $\\textsf{MtAwc}$ protocol, Step 2, Bob proofs in ZK that he knows $b \u0026lt; q^3$, $\\beta\u0026rsquo; \u0026lt; q^7$ such that the ciphertext $c_B = b \\times_E c_A +_E E_A(\\beta\u0026rsquo;)$. In the Key generation protocol, Phase 1, each player $P_i$ commits to the value $g^{u_i}$. In the Key generation protocol, Phase 3, each party $P_i$ proofs in ZK the following statements:  That he knows $x_i$ such that $X_i = g^{x_i}$ using a Schnorr\u0026rsquo;s protocol. That $N_i$ is square-free.   In the Signature generation protocol, Phase 1, each party $P_i$ commits to the value $g^{\\gamma_i}$. In the Signature generation protocol, Phase 4, each party $P_i$ proves in ZK that he knows $\\gamma_i$ such that $\\Gamma_i = g^{\\gamma_i}$ using a Schnorr\u0026rsquo;s protocol. In the Signature generation protocol, Phase 5, each party $P_i$ computes the following commitments and ZK proofs:  In Step (5A), the player $P_i$ commits to the value of $(V_i, A_i)$. In Step (5B), the player $P_i$ proves in ZK that he knows $s_i, l_i, \\rho_i$ such that $V_i = R^{s_i} g^{l_i}$ and $A_i = g^{\\rho_i}$. In Step (5C), the player $P_i$ commits to the value of $(U_i, T_i)$.    References #   Gennaro, R., \u0026amp; Goldfeder, S. (2018). Fast Multiparty Threshold ECDSA with Fast Trustless Setup. In Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security (pp. 1179–1194). Association for Computing Machinery. Dmytro Tymokhanov, \u0026amp; Omer Shlomovits. (2021). Alpha-Rays: Key Extraction Attacks on Threshold ECDSA Implementations.  "},{"id":7,"href":"hashcloak.com/mpcsecurity/docs/threshold_ecdsa_protocols/gennaro_goldfeder_2020/","title":"$(t, n)$ case from Gennaro \u0026 Goldfeder (2020)","section":"Threshold ECDSA protocols","content":"$(t, n)$ case from Gennaro \u0026amp; Goldfeder (2020) #  This work is an improvement on the work of Genaro \u0026amp; Goldfeder (2019). Here, Genaro and Goldfeder present a $(t, n)$ threshold DSA/ECDSA signature protocol in the dishonest majority security model. The main contribution with respect to the work of Genaro \u0026amp; Goldfeder (2019) is that this work provides mechanisms to identify which player is misbehaving in case of an abort. Also, they design a protocol where all the heavy computation can be performed in an offline phase, that is before the message to be signed is known. Once the preprocessing is finished, the parties engage in an online phase that requires only one round.\nFor the key generation protocol and the signing protocol, we will present their specifications and then we will show the mechanism used to identify the corrupt parties.\nSimilar to the previous version of the protocol, we will use the multiplicative notation for the group $\\mathcal{G}$ described by a generator $g$.\nPreliminaries #  As in the work of Gennaro \u0026amp; Goldfeder (2019), this work relies on the following preliminaries:\n Additive homomorphic encryption. Non-malleable equivocable commitments. Verifiable secret-sharing schemes. The multiplicative to additive share conversion protocols $\\textsf{MtA}$ and $\\textsf{MtAwc}$.  We will not cover the above elements because they were covered in the previous section of this document. Also, this work focuses on proposing a threshold signature protocol for DSA. Given that this signature algorithm was specified with details in the previous section, we refrain from showing the details here again.\nIdentifiable abort #  It is well known that in an active security model, it is not possible to guarantee the output delivery of the execution of an MPC protocol. If the adversary is active, a corrupt party may refrain from sending the message supposed to be sent which causes honest parties will not learn the output of the computation. In this situation, the protocol proposed by Gennaro \u0026amp; Goldfeder reaches security with abort which means that the adversary can cause the protocol to abort, but in doing so can not learn anything else other than its outputs.\nWhen an abort is produced by the adversary, the protocol proposed in this work guarantees that the honest parties agree on the identity of a party $P_i$ which is a corrupted party. More technically, if F is a functionality computed by the original protocol, then a protocol for F with identifiable abort either computes F or the identity of a corrupted party $P_i$ in case of an abort.\nKey generation protocol #  The key generation protocol for this work is very similar to the one presented in Gennaro \u0026amp; Goldfeder (2019). We present it here for completeness. At the end of the protocol, each party $P_i$ will obtain $(t, n)$-shares $x_i$ of a secret key $x$ along with a public key $y = g^x$. Also at the end of the protocol the value of $X_i = g^{x_i}$ is made public.\nSigning protocol #  Once the key generation protocol has been executed, the signing protocol is run on input $m$ with $m = H(M)$. Let $S \\subseteq [n]$ be the set of players involved in the signing protocol. By using the correct Lagrange coefficients, which can be computed locally by each party, each player $P_i$ can compute an additive share of $x$ by letting $w_i = \\lambda_{i,S} \\cdot x_i$, where $\\lambda_{i,S}$ is the Lagrange coefficient. Notice that $x = \\sum_{i \\in C} w_i$. Also, given that $X_i = g^{x_i}$ is public (which was computed in the key generation protocol), each party can compute $W_i = X_i^{\\lambda_{i, S}} = g^{w_i}$. Below, we present the protocol:\nZero-knowledge proofs #  In the middle of the signing protocol, there are two ZK-proofs that need to be done to guarantee the correctness of the computation.\nFor the first proof required in Phase 3, the party $P$ outputs $T = g^\\sigma h^l$ and must provide proof that he knows $\\sigma$ and $l$ satisfying those equalities. A solution for an honest verifier is as follows:\nAnother proof that is required in Phase 5, requires that player $P$ who outputs $\\bar{R} = R^k$, has to prove that he knows an exponent $k$ consistent with a Paillier ciphertext previously posted $C = E(k)$. A ZK-proof for this statement can be realized using works like MacKenzie \u0026amp; Reiter (2004) and Gennaro et al. (2016).\nFinally, in Step 6, a player $P$ outputs $S = R^{\\sigma}$, and must prove that he knows $\\sigma, l$, such that fulfills the previous equality and that $T = g^\\sigma h^l$. A ZK-proof for this argument is:\nIdentifying aborts #  As we mentioned before, the protocol presented here has the possibility to identify at least one party responsible for causing an abort in case the latter occurs. In this section, we present the strategies that the present reviewed work takes to make identification possible.\nKey generation #  In the key generation, there are two points in which the protocol may fail and abort:\n In Phase 2, a player can complain about receiving an inconsistent Feldman\u0026rsquo;s share. In Phase 3, each player proves knowledge of $x_i$ and proves the correctness of their Paillier key. If the proofs fail, then the abort occurs.  If the abort occurs in Phase 3, it is easy to return the identity of the corrupt party. In the second section, a party $P_j$ complains about the inconsistency of a share coming from party $P_i$. In that case, there are two possibilities: (1) $P_j$ in fact received an inconsistent share or (2) $P_j$ is the corrupt party trying to frame $P_i$.\nTo figure out what of the above situations is really happening, the party $P_j$ reveals the share received from $P_i$ to every other party, and every other party can confirm the consistency of the share of $P_i$. If we assume that the shares are signed, $P_i$ cannot be framed by $P_j$. Notice that opening this share does not hurt the security of the overall protocol because the signature has not been established or used.\nSigning protocol #  In the signing protocol, an abort may occur in the following points:\nFor 1, 2, 3, 4, and 6, the identification of the corrupt party is simple. For the case of item 8, when the signature $(r, s)$ does not verify correctly, it means that at that point $g = \\prod \\bar{R}_i$ (from Phase 5) and also $y = \\prod S_i$ (from Phase 6). At the point of abort, the party $p_i$ can broadcast $s_i$ and check if $R^{s_i} = \\bar{R}_i^m \\cdot S_i^r$ and the corrupt party would be the party for which this equality does not hold.\nIt remains to show how to deal with items 5 and 7. According to Gennaro \u0026amp; Goldfeder, the parties ran the protocol correctly if and only if we prove the following:\nAccording to the protocol specifications, Properties 1 and 2 are already enforced because of protocols $\\textsf{MtA}$ and $\\textsf{MtAwc}$. Thus, to make the protocol identifiable, Gennaro \u0026amp; Goldfeder attend Properties 3, 4, and 5 separately.\nThe solution to the remaining properties is based on the fact that $k$ and $\\gamma$ can be revealed as long as a signature $s$ has not been published. It can be seen that revealing $k$ as long as a signature $s$ using $k$ allows an attacker to compute the private key $x$ efficiently. The same holds for shares $k_i$ and $s_i$: if $s_i$ has not been published, then it is possible to reveal $k_i$ without hurting the security of the signature scheme.\nIf the protocol aborts in Phase 5 because $g \\neq \\prod \\bar{R}_i$, the identification protocol works as follows:\nFor the case of aborts of type 7 in Phase 6, the protocol aborts because $y \\neq \\prod S_i$. In this case, the parties cannot open the $\\textsf{MtAwc}$ protocol between $k_i$ and $w_i$ given that $w_i$ is a share for the secret key. However, it is safe to reveal $\\mu_{ij}$ in the clear to check the correctness of $\\sigma_i$ in the exponent. We can identify the corrupt party as follows - we corrected some typos in this section of the protocol:\n Each player $P_i$ publishes $k_i$ and $\\mu_{ij}$ as the decryption of the appropriate cyphertext in the $\\textsf{MtAwc}$ protocol. Every other party $P_l$ can now verify that the value sent by $P_i$ to $P_j$ was $k_i$ and the value sent by $P_j$ to $P_i$ was $\\mu_{ij}$. Given that $g^{w_j}$ is a public value, every party can compute $g^{\\nu_{ij}}$ using the equation $g^{\\mu_{ij}} = g^{w_j k_i} g^{-\\nu_{ij}}$. Then, they can compute $$ g^{\\sigma_i} = g^{w_i k_i} \\prod_{j \\neq i}g^{\\mu_{ij}} \\prod_{j \\neq i}g^{\\nu_{ij}} $$ Each player $P_i$ proofs in zero-knowledge the consistency between $g^{\\sigma_i}$ from the previous step and $S_i = R^{\\sigma_i}$. If the test does not hold for some player, then the abort is attributed to that player.  The ZK-proof of the last step can be found in Chaum \u0026amp; Pedersen (1993).\nSimplified ECDSA with anonymous aborts #  In the case that one is not concerned about identifying aborts, the authors of the revisited work propose a simpler protocol. The key generation is the same as in the previous protocol, but the signing protocol is slightly different than the previous one. As in the previous protocol, by using the correct Lagrange coefficients, each player $P_i$ can compute an additive share of $x$ by letting $w_i = \\lambda_{i,S} \\cdot x_i$, where $\\lambda_{i,S}$ is the Lagrange coefficient. Again, notice that $x = \\sum_{i \\in C} w_i$. Also, given that $X_i = g^{x_i}$ is public (which was computed in the key generation protocol), each party can compute $W_i = X_i^{\\lambda_{i, S}} = g^{w_i}$. We present the simplified signature generation protocol next:\nSecurity concerns #   The original paper of this work is obsolete due to some missing details in the protocol. Also, the proof of the protocol is not correct. It is imperative to check that the protocol fulfills all the specifications of the new version of the work. The security of this protocol relies on a stronger assumption of the unforgeability of ECDSA. It is relevant to check if these assumptions are suitable and enough for the use case. In the previous version of the paper, the simulatability for the protocol $\\textsf{MtAwc}$ of the protocol does not hold. In particular, in the case of choosing a small Paillier modulus $N$, the adversary can leverage this fact to retrieve the entire share of the secret key of an honest party. Choosing $N \u0026gt; q^7$ makes the protocol to be secure against this attack. However, the previous version is vulnerable to this attack for implementations that neglected to take into account this advice about the lower bound of $N$. In the specification of the protocol, party $P_2$ makes sure that the correct value of $N$ is being used. The protocol assumes the existence of a broadcast channel and point-to-point channel connectivity between each pair of players. If any party notices an inconsistency in the information sent using the broadcast channel, the protocol must abort and notify every other party. The protocol has security guarantees against static corruption. We need to check that this fact is fulfilled in the use case. The authors suggest that the protocol requires non-malleable commitment schemes that are \u0026ldquo;concurrently\u0026rdquo; secure. In the paper, there are presented some alternatives to implement this type of commitment. In the verifiable secret-sharing schemes (VSS), if the check does not hold for any player, the party raises a complaint and the protocol must abort. In the previous version, the protocol chose $\\beta\u0026rsquo;$ at random and did not perform any range check on it as in the most recent version. This fact also induces an attack similar to the one used on $N$ mentioned in a previous concern. Also, the previous version of the paper uses ZK-proofs that need to be adapted to the bounds presented in the most recent version. This paper does not specify what is $h$ in Phase 3. According to one of the authors, this $h$ is a second generator of the curve for which the parties do not know the exponent. In Phase 5, parties need to check whether $g = \\prod_{i \\in S} \\bar{R}_i$. If not, the protocol should abort. In Phase 6, each party $P_i$ broadcast $S_i = R^{\\sigma_i}$, with a ZK-proof to show the consistency between $S_i$ and $T_i$. Also, the parties need to check whether $y = \\prod_{i \\in S} S_i$. In Phase 7, if the resulting signature is not a valid signature for $m$, the protocol must abort. To identify aborts, the parties assume that all messages transferred between parties are signed to establish their origin. The protocol assumes that there is a broadcast channel to identify the corrupt party that caused an abort. Moreover, this means that every message in the protocol has to be reliably broadcast. If the message of some party does not arrive, a local timer is set to some timeout bound before marking that party as corrupt. When a corrupt party is identified after an abort, the key generation needs to be re-run with fresh randomness to establish a new secure key. To detect the corrupt party, the protocol must check the aborts produced in the items presented in Section 4.2. It is needed special attention to Items 5, 7, and 8:  For item 8, the parties can check if $R^{s_i} = \\bar{R}^m_i \\cdot S_i^r$. If the equation does not hold for some party $P_i$, then it will be the corrupt party. For items 5 and 7, the instructions can be found in Section 4.3.   There is a possible typo in Section 4.3 in the specification of how to identify the corrupt party for Items of type 7. The correct version of the equation in numeral 2 should be: $g^{\\mu_{ij}} = g^{w_j k_i} g^{-\\nu_{ij}}$, and the next equation should be: $$ g^{\\sigma_i} = g^{w_j k_i} \\prod_{i \\neq j} g^{\\mu_{ij}} \\prod_{i \\neq j} g^{\\nu_{ij}} $$ In the simplified version of the protocol for anonymous aborts, the parties should check in Step 7 that $\\Lambda = g^\\delta$. If the condition holds, the players $P_i$ broadcasts $s_i$, otherwise, the protocol aborts. There is a small typo in Phase 5: the zero-knowledge proof of consistency is done between $\\bar{R}_i$ and $E_i(k_i)$.  ZK-proofs and commitments #  For the version with identifiable aborts #   In the $\\textsf{MtAwc}$ protocol, Step 1, the party $P_1$ proves in zero-knowledge that $a$ is the decryption of $c_A$ under the public key of $P_1$ and that $a \u0026lt; q^3$ using a range proof. In the $\\textsf{MtAwc}$ protocol, Step 1, the party $P_2$ proves in zero-knowledge that $b \u0026lt; q^3$, $\\beta\u0026rsquo; \u0026lt; q^7$, and $c_B = b \\times_E c_A +_E E_1(\\beta\u0026rsquo;)$. In case that $B = g^b$ is public, instead of the previous proof, $P_2$ proves in zero-knowledge that $b \u0026lt; q^3$, $\\beta\u0026rsquo; \u0026lt; q^7$, $c_B = b \\times_E c_A +_E E_1(\\beta\u0026rsquo;)$ and $B = g^b$. In the Key generation protocol, party $P_i$ executes the following proofs and commitments:  In Phase 1, he/she commits to the value of $g^{u_i}$. In Phase 3, he/she proves in zero-knowledge that he knows $x_i$ such that $X_i = g^{x_i}$ using a Schnorr\u0026rsquo;s proof, and that $N_i$ is square-free and that $h_1, h_2$ generates the same modulo $N_i.$   In the Signing protocol, each party $P_i$ executes the following zero-knowledge proofs and commitments:  In Phase 1, the party commits to the value of $g^{\\gamma_i}$. In Phase 3, the party proves in ZK that he knows $\\sigma_i$ and $l_i$ such that $T_i = g^{\\sigma_i} h^{l_i}$. In Phase 5, the party proves that the value of $\\bar{R}_i$ and $E_i(k_i)$ are consistent, where the latter is the first message sent in the $\\textsf{MtAwc}$ protocol executed in Phase 2. In Phase 6, the party proves in ZK the consistency between the values $S_i$ and $T_i$.   In the Identification process for failures of Type 7 (in Phase 6), each party $P_i$ proves in zero-knowledge that the values of $g^{\\sigma_i}$ and $S_i = R^{sigma_i}$ are consistent.  For the simplified version with anonymous aborts #  In the Signing protocol, each party $P_i$ executes the following zero-knowledge proofs and commitments:\n In Phase 1, the party commits to the value of $g^{\\gamma_i}$. In Phase 5, the party proves in ZK that the values of $\\Lambda_i$ and $E_i(k_i)$ are consistent, where the latter is the first message sent in the $\\textsf{MtAwc}$ protocol in Phase 2.  References #   Rosario Gennaro, \u0026amp; Steven Goldfeder. (2020). One Round Threshold ECDSA with Identifiable Abort. Chaum, D., \u0026amp; Pedersen, T. P. (1993). Wallet Databases with Observers. In E. F. Brickell (Ed.), Advances in Cryptology — CRYPTO’ 92 (pp. 89–105). Springer Berlin Heidelberg. MacKenzie, P., \u0026amp; Reiter, M. K. (2004). Two-party generation of DSA signatures. International Journal of Information Security, 2(3), 218–239. https://doi.org/10.1007/s10207-004-0041-0. Gennaro, R., Goldfeder, S., \u0026amp; Narayanan, A. (2016). Threshold-Optimal DSA/ECDSA Signatures and an Application to Bitcoin Wallet Security. In M. Manulis, A.-R. Sadeghi, \u0026amp; S. Schneider (Eds.), Applied Cryptography and Network Security (pp. 156–174). Springer International Publishing.  "},{"id":8,"href":"hashcloak.com/mpcsecurity/docs/threshold_ecdsa_protocols/lindell_2018/","title":"$(t, n)$ case from Lindell et al. (2018)","section":"Threshold ECDSA protocols","content":"$(t, n)$ case from Lindell et al. (2018) #  This paper presents a full-threshold ECDSA signing protocol which is the first to have a practical distributed key generation and fast signing. The protocol can be divided into two phases: in the first phase, they propose a protocol based on Pedersen commitments; in the second phase, they replace the Pedersen commitments for ElGamal-in-the-exponent encryption to improve the performance of the protocol.\nThe strategy of this work is to first propose a protocol for a non-threshold case (i.e. $n$-out-of-$n$, you need all the parties to generate a key and compute a signature). Then they work towards the required solution: first, they propose a solution for an adversary controlling an arbitrary number of parties, and then they propose a solution for the threshold case $t$-out-of-$n$. In intermediate steps, they also propose more efficient alternatives aiming to reduce the number of rounds.\nPreliminaries #  Here we denote by $G$ to the generator of an elliptic curve group $\\mathbb{G}$ of prime order $q$ using additive notation. Therefore, each element can be described as $a \\cdot G$ for $a \\in \\mathbb{Z}_q$. Also, we denote $\\widetilde{\\mathbb{G}} = \\mathbb{G} \\times \\mathbb{G}$ as the product group which inherits the natural group operation from $\\mathbb{G}$. The elements of $\\widetilde{\\mathbb{G}}$ will be denoted as $\\widetilde{A}$. Also, we fix a security parameter $\\kappa \\in \\mathbb{N}$ for the rest of the section. When describing the protocols, let $\\textsf{Store}_k(v)$ be the functionality that stores the value $v$ under the key $k$. Also, let $\\textsf{Retrieve}(k)$ be the functionality that returns the value stored under key $k$ or aborts if such key does not exist.\nA Pedersen commitmet of a value $m \\in \\mathbb{Z}_q$ using a public key parameter $D$ and randomness $r$ is defined by\n$$ \\textsf{PedCom}_D(m; r) = r \\cdot D + m \\cdot G $$\nWhen it is clear from the context, the authors omit the random parameter $r$ in the notation. The authors denote a Pedersen commitment by $\\widehat{A} = \\textsf{PedCom}_D(a; r)$, for some $a \\in \\mathbb{Z}_q$. An important feature of Pedersen commitments is that they are homomorphic with respect to the addition in $\\mathbb{G}$. Therefore, if $\\widehat{A}_0 = \\textsf{PedCom}_D(m_1; \\cdot)$ and $\\widehat{A}_2 = \\textsf{PedCom}_D(m_2; \\cdot)$, then $\\widehat{A}_1 + \\widehat{A}_2$ is a commitment for $m_1 + m_2$.\nAn ElGamal commitment of a message $m \\in \\mathbb{Z}_q$ with public key $E \\in \\mathbb{G}$ and randomness $r$ is defined to be\n$$ \\textsf{EgCom}_E(m; r) = ( r \\cdot G, r \\cdot E + m \\cdot E ), $$\nwhich turns out to be an element of $\\widetilde{\\mathbb{G}}$. Therefore, we denote the ElGamal commitments as $\\widetilde{A} = \\textsf{EgCom}_E(a; r)$, for $a \\in \\mathbb{Z}_q$. Similarly to Pedersen commitments, ElGamal commitments are also homomorphic concerning the group operation in $\\widetilde{\\mathbb{G}}$.\nThe protocols presented in the work covered here depend on ZK-PoK functionalities denoted as $\\mathcal{F}_\\textsf{zk}^\\mathcal{R}$ for a relation $\\mathcal{R}$. The paper also lists the relations that will be presented next, but we also include the relations to present a self-contained material and also correct some typos present in the paper. The relations covered in this work will be the following:\n  Knowledge of discrete log:\n$$ \\mathcal{R}_\\textsf{DL} = \\left\\{(A, B, w ) \\;\\vert\\; B = w \\cdot A \\right\\}. $$\n  $\\textsf{DH}$ tuple:\n$$ \\mathcal{R}_\\textsf{DH} = \\left\\{ \\left(\\widetilde{A} = (A_1, A_2), \\widetilde{B} = (B_1, B_2), w \\right) \\;\\vert\\; \\widetilde{B} = w \\cdot \\widetilde{A} \\right\\}. $$\nWe write $\\left(A, \\widetilde{B}, w\\right) \\in \\mathcal{R}_\\textsf{DH}$ as a shorthand for $\\left((G, A), \\widetilde{B}, w \\right) \\in \\mathcal{R}_\\textsf{DH}$.\n  Knowledge of Pedersen commitment:\n$$ \\mathcal{R}_\\textsf{PedKlwg} = \\left\\{ \\left((D, \\widehat{A}), (a, r) \\right) \\;\\vert\\; \\widehat{A} = \\textsf{PedCom}_D(a; r) \\right\\}. $$\n  Pedersen commitment of a value:\n$$ \\mathcal{R}_\\textsf{PedEqVal} = \\left\\{ \\left( (D, \\widehat{A}, A), r \\right) \\;\\vert\\; \\widehat{A} = \\textsf{PedCom}_D(a; r) \\right\\}. $$\n  Pedersen commitment of a value in the exponent:\n$$ \\mathcal{R}_\\textsf{PedEqVal} = \\left\\{ \\left( (D, \\widehat{A}, A), (a, r) \\right) \\; \\vert \\; \\widehat{A} = \\textsf{PedCom}_D(a;r), \\; A = a \\cdot G \\right\\} $$\n  Knowledge of ElGamal commitment: $$ \\mathcal{R}_\\textsf{EGKlwg} = \\left\\{ \\left( (E, \\widetilde{A}), (a, r) \\right) \\; \\vert \\; \\widetilde{A} = \\textsf{EgCom}_E (a; r) \\right\\} $$\n  ElGamal equals Pedersen: here, we correct a typo present in the paper.\n$$ \\mathcal{R}_\\textsf{EgEqPed} = \\left \\{ \\left ( (E, \\widetilde{A}, D, \\widehat{A}), (a, \\tilde{r}, \\hat{r}) \\right ) \\; \\vert \\; \\widetilde{A} = \\textsf{EgCom}_E(a; \\tilde{r}) \\; \\wedge \\; \\widehat{A} = \\textsf{PedCom}_D(a; \\hat{r}) \\right \\} $$\n  Knowledge of ElGamal scalar product:\n$$ \\mathcal{R}_\\textsf{EgProdScalar} = \\left \\{ \\left( (E, \\widetilde{A}, \\widetilde{B}), (r, c)) \\right) \\;\\vert\\; \\widetilde{B} = c \\cdot \\widetilde{A} + \\textsf{EgCom}_E(0; r) \\right \\} $$\n  Product of ElGamal commitments:\n$$ \\mathcal{R}_\\textsf{EgProdEg} = \\left\\{ \\left( (E, \\widetilde{A}, \\widetilde{B}, \\widetilde{C}), (r^b, r^0, b) \\right) \\; \\vert \\; \\widetilde{B} = \\textsf{EgCom}_E(b; r^b) \\; \\wedge \\; \\widetilde{C} = b \\cdot \\widetilde{A} + \\textsf{EgCom}_E(0, r^0) \\right\\} $$\n  ElGamal commitment of a value:\n$$ \\mathcal{R}_\\textsf{EgEqVal} = \\left\\{\\left( (E, \\widetilde{A}, a), r \\right) \\;\\vert\\; \\widetilde{A} = \\textsf{EgCom}_E(a; r), \\; A = a \\cdot G \\right\\} $$\n  ElGamal commitment of a value in the exponent:\n$$ \\mathcal{R}_\\textsf{EgEqExp} = \\left\\{ \\left( (E, \\widetilde{A}, A), (a, r) \\right) \\; \\vert \\; \\widetilde{A} = \\textsf{EgCom}_E(a; r), \\; A = a \\cdot G \\right\\} $$\n  ECDSA protocol #  Now, we present an ECDSA protocol for the non-threshold case. This specification was taken directly from Lindell et al. (2018). The high-level idea of the protocol is the following. The signing protocol is a traditional coin-tossing protocol that outputs a random element in the group $\\mathbb{G}$ but each party has an additive share of the private key, which in this case is the discrete logarithm of the public key. The signing protocol applied to a message $m$ works by generating shares of two values $\\rho, k \\in \\mathbb{Z}_q$ and then computing the exponent $R = k \\cdot G = (r, \\cdot)$. Therefore, parties compute $\\beta = \\rho \\cdot (H(m) + x \\cdot r)$, and output $(r, s = \\tau^{-1} \\cdot \\beta)$ as the signature. Notice that\n$$ \\tau^{-1} \\beta = \\rho^{-1} \\cdot k^{-1} \\cdot \\rho \\cdot (H(m) + x \\cdot r) = k^{-1} \\cdot (H(m) + x \\cdot r), $$\nwhich is precisely the signature shown in the standalone version of ECDSA.\nKey generation #  On input $(\\textsf{sid}, \\textsf{KeyGen})$, party $P_i$ acts as follows:\n Let $\\textsf{oid}_x = \\textsf{sid} \\;\\Vert\\; \u0026ldquo;x\u0026rdquo;$. The parties engage in $\\textsf{CreateSharedVal} \\left( \\textsf{sid}, D, \\textsf{oid}_x \\right)$. The parties engage in $\\textsf{OutExpOfSharedVal} \\left( \\textsf{sid}, D, \\textsf{oid}_x \\right)$ Output $X$.  Signing #  On input $(\\textsf{sid}, \\textsf{Sign}, \\textsf{oid}_x, m)$, party $P_i$ acts as follows:\n Abort if $\\textsf{oid}_x$ was not stored. Let $\\textsf{oid}_k = \\textsf{sid} \\Vert 1$, $\\textsf{oid}_\\rho = \\textsf{sid} \\Vert 2$, $\\textsf{oid}_{\\rho \\cdot k} = \\textsf{sid} \\Vert 3$, $\\textsf{oid}_{\\rho \\cdot x} = \\textsf{sid} \\Vert 4$, $\\textsf{oid}_{r \\cdot \\rho \\cdot x} = \\textsf{sid} \\Vert 5$, $\\textsf{oid}_{\\rho \\cdot m} = \\textsf{sid} \\Vert 6$, $\\textsf{oid}_\\beta = \\textsf{sid} \\Vert 7$. In parallel, the parties engage in: $\\textsf{CreateSharedVal} \\left( \\textsf{sid}, D, \\textsf{oid}_\\rho \\right)$ and $\\textsf{CreateSharedVal} \\left( \\textsf{sid}, D, \\textsf{oid}_k \\right)$. Here $\\rho$ and $k$ denote the generated values. In parallel, the parties engage in:  $\\textsf{MultSharedVals}(\\textsf{sid}, D, \\textsf{oid}_\\rho, \\textsf{oid}_k, \\textsf{oid}_{\\rho \\cdot k})$. $\\textsf{MultSharedVals}(\\textsf{sid}, D, \\textsf{oid}_\\rho, \\textsf{oid}_x, \\textsf{oid}_{\\rho \\cdot x})$.   The parties engage in $\\textsf{OutExpOfSharedVal}(\\textsf{sid}, D, \\textsf{oid}_k)$. Let $(r\u0026rsquo;, \\cdot)$ be the common output and let $r = r\u0026rsquo; \\mod q$. Each party invokes:  $\\textsf{ScalarMultOfSharedVal}(D, \\textsf{oid}_{\\rho \\cdot x}, \\textsf{oid}_{r \\cdot \\rho \\cdot x}, r)$. $\\textsf{ScalarMultOfSharedVal}(D, \\textsf{oid}_{\\rho}, \\textsf{oid}_{r \\cdot m}, H(m))$. $\\textsf{AdditionOfSharedVals}(D, \\textsf{oid}_{r \\cdot \\rho \\cdot x}, \\textsf{oid}_{r \\cdot m}, \\textsf{oid}_{\\beta})$.   In parallel, parties engage in:  $\\textsf{OutSharedVal}(D, \\textsf{sid}, \\textsf{oid}_{\\rho \\cdot k})$; let $\\tau$ be the common output. $\\textsf{OutSharedVal}(D, \\textsf{sid}, \\textsf{oid}_{\\beta})$; let $\\beta$ be the common output.   Output $\\left( r, s = \\tau^{-1} \\cdot \\beta \\right)$.  Next, we describe the protocols $\\textsf{CreateSharedVal}$, $\\textsf{AdditionOfSharedVals}$, $\\textsf{ScalarMultOfSharedVal}$, $\\textsf{OutSharedVal}$, $\\textsf{OutExpOfSharedVal}$, and $\\textsf{MultSharedVals}$\nProtocol $\\textsf{CreateSharedVal}$: #  This protocol creates a Pedersen commitment to a uniformly chosen value. Each party will hold a share of this value which will remain private.\nProtocol $\\textsf{AdditionOfSharedVals}$ #  This protocol adds two committed values under Pedersen commitment. Remember that Pedersen commitments are additively homomorphic, therefore, this operation can be computed locally by each party.\nProtocol $\\textsf{ScalarMultOfShareVals}$ #  This protocol multiplies a publicly known scalar with a previously stored value that is committed under a Pedersen commitment. Knowing that such commitment is additively homomorphic, this operation can be computed locally by each party.\nProtocol $\\textsf{OutSharedVal}$ #  This protocol reconstructs an additively shared value whose shares have been committed using a Pedersen commitment.\nProtocol $\\textsf{OutExpSharedVal}$ #  This protocol outputs the value $A = a \\cdot G$ for a previously stored value $a$. Here, the functionality is omitting that the party should compute $A_i = a_i \\cdot G$ at some point before Step 2.Protocol $\\textsf{MultSharedVals}$ #  This protocol multiplies a pair of previously generated and stored values and stores an additive share of the multiplication.\nThe functionality $\\mathcal{F}_\\textsf{LeakyMult}$ is a many-party leaky multiplication ideal functionality that multiplies two private values and returns the additive share of the multiplication to each party. Here, they say that it is leaky because the functionality allows the adversary to know whether a linear relationship of the private shares of each value is equal to some value. Also, the functionality allows the adversary to modify their commitments restricted to the condition of preserving the overall sum. The purpose of giving the adversary this freedom is to obtain more efficient implementations of the protocol. Next, we will show the specification of this functionality. Here we correct some typos present in the paper:\nFunctionality $\\mathcal{F}_\\textsf{LeakyMult}$:\nParties: $P_1, \\dots, P_n$. Common input: $\\textsf{sid} \\in \\{0, 1\\}^*$, $D \\in \\mathbb{G}$, $\\left\\{ \\widehat{A}_\\mathcal{l}, \\widehat{B}_\\mathcal{l} \\right\\}_{l=1}^n$. $P_i$\u0026rsquo;s input: $\\left(a_i, r_i^A \\right), \\left(b_i, r_i^B \\right) \\in \\mathbb{Z}_q^2$.\n Abort if for some $\\mathcal{l}$ it holds that $\\widehat{A}_\\mathcal{l} \\neq \\textsf{PedCom}_D(a_\\mathcal{l}, r_\\mathcal{l}^A)$ or $\\widehat{B}_\\mathcal{l} \\neq \\textsf{PedCom}_D(b_\\mathcal{l}, r_\\mathcal{l}^B)$ Sample $r_1, \\dots, r_n$ uniformly at random from $\\mathbb{Z}_q$. Sample $c_1, \\dots, c_n$ uniformly at random from $\\mathbb{Z}_q$ conditioned on $$ \\sum_{l=1}^n c_l = \\left(\\sum_{l=1}^n a_l \\right) \\cdot \\left(\\sum_{l=1}^n b_l \\right). $$ Output $\\left\\{C_l = \\textsf{PedCom}_D(c_l; r_l)\\right\\}_{l=1}^n$ as the common output. Send $\\left( r_l, c_l \\right)$ to $P_l$ for each $l = 1, \\dots, n$.  After getting the outputs, the corrupted parties $\\mathcal{C}$ can make the following calls (at most one of each type):\n Linear test: send $\\delta \\in \\mathbb{Z}_q$ and $\\left\\{(o_l^A, o_l^B) \\in \\mathbb{Z}_q^2\\right\\}_{l \\in [n] \\setminus \\mathcal{C}}$ to the functionality. The functionality aborts if $\\sum_{l \\in [n] \\setminus \\mathcal{C}} (o_l^A \\cdot a_l + o_l^B \\cdot b_l) \\neq \\delta$. Commitment replacement: Send $\\{(r\u0026rsquo;_l, c\u0026rsquo;_l )\\}_{l \\in \\mathcal{C}}$. The functionality aborts if $\\sum_{l \\in \\mathcal{C}} c_l \\neq \\sum_{l \\in \\mathcal{C}} c\u0026rsquo;_l$. Otherwise the value of $\\widehat{C}_l$, for each $l \\in \\mathcal{C}$, in the common output is updated to $\\textsf{PedCom}_D(c\u0026rsquo;_l; r\u0026rsquo;_l)$.  Threshold case #  To this moment, the protocol allows an adversary to corrupt at least $n - 1$ parties. Now, we present an adjustment from Lindell et al. (2018) for adversaries corrupting less than $n - 1$ parties. For this modification, we define the public view of a party to the public information it sends and receives: inputs received from the environment, messages it sends and receives, and outputs of the common output ideal functionalities. Also, we call an outputting round a round in which the honest parties output a value. The adjustment is as follows:\n In each round that proceeds an outputting round, each hones party sends a hash of its public view to all parties. That is, $H\u0026rsquo;(v)$ where $H\u0026rsquo;$ is an arbitrary collision-resistant hash function, and v is its current public view. In each outputting round, an honest party first verifies that the hash of all other parties\u0026rsquo; public view is consistent with its own.  To achieve threshold signatures (i.e. signatures $t$-out-of-$n$), the approach is as follows. In the key generation, the parties generate additive shares as in the $n$-out-of-$n$ case and transform such shares into $t$-out-of-$n$ shares using Shamir secret-sharing. For the signing phase, the parties take the Shamir $t$-out-of-$n$ shares transform them into $t$-out-of-$t$ shares, and proceed as in the non-threshold case.\nThe protocol for key generation is presented next. One thing that is missing in the protocol specification is that in Step 2(e)(ii), the parties should execute $\\mathcal{F}_{\\textsf{zk}}^{\\mathcal{R}_\\textsf{DL}}$ with respect to $D$ given that, under correct circumstances, this should be a Pedersen commitment of 0. Also, here $p_{i, l}$ is a notation for $p_i(l)$.The protocol for signing is presented next. Here we present a relevant correction to the protocol presented in the original paper. Let $\\mathcal{S} \\subseteq [n]$ be the set of active parties (i.e. parties involved in the signing protocol). Abort if $\\vert \\mathcal{S} \\vert \\neq t$. (Locally) Generate additive shares of $x$.  For $l \\in \\mathcal{S}$, let $$ o_l = \\frac{\\prod_{j \\in \\mathcal{S}\\setminus\\{l\\}} j}{\\prod_{j \\in \\mathcal{S}\\setminus\\{l\\}} (j - l)}. $$ Let $\\left( \\{ \\widehat{A}_l \\}_{l=1}^n, a_i, r_i \\right) = \\textsf{Retrieve}(\\textsf{oid}_\\textsf{xtsh})$. Let $(a\u0026rsquo;_i, r\u0026rsquo;_i) = o_i \\cdot (a_i, r_i)$, and for each $l \\in \\mathcal{S}$, let $\\widehat{A}\u0026rsquo;_l = o_l \\cdot \\widehat{A}_l$.   Sign using additive shares:  $\\textsf{Store}_{\\textsf{oid}\u0026rsquo; = \\textsf{sid} \\Vert \u0026ldquo;y\u0026rdquo;} \\left( \\{ \\widehat{A}\u0026rsquo;_l \\}_{l=1}^n, a\u0026rsquo;_i, r\u0026rsquo;_i \\right)$. Interact as in the signing phase of the signing protocol for the non-threshold case, while in the call of $\\textsf{MultSharedVals}$ done in Round 4(2), use the object-id $\\textsf{oid}\u0026rsquo;$ instead of $\\textsf{oid}$.    We remain to present a UC-realization of $\\mathcal{F}_\\textsf{LeakyMult}$ which is the protocol $\\textsf{ManyPartyLeakyMult}$. Such protocol has access to other two ideal functionalities: a two-party multiplication functionality $\\mathcal{F}_\\textsf{2PC-Mult}$ and a multiplication equality test functionality $\\mathcal{F}_\\textsf{PedMultEqTest}$. For this text to be self-contained, we present the functionalities next taken from the original paper:\n We stress that performing the check using $\\mathcal{F}_\\textsf{PedMultEqTest}$ is key because the functionality for multiplications does not force the parties to input the correct and committed values, resulting in a wrong output. Then, the functionality for multiplication check will be in charge of testing and avoiding this behavior. The functionality $\\mathcal{F}_\\textsf{2PC-Mult}$ will be then replaced by a more weak functionality $\\mathcal{F}_\\textsf{2PC-WeakMult}$. Whose realization can be found in Haitner et al. (2021), and such replacement will not affect the security of the overall protocol. For reference, we present next the weak functionality. It is important to mention that the version of this functionality in the paper of Lindell et al. has a small typo in the number of elements of $v$. The following functionality has the correct specification.Also, we next present the functionality $\\mathcal{F}_\\textsf{PedMultEqTest}$:\nNow, having all the functionalities, we present the protocol $\\textsf{ManyPartyLeakyMult}$ that UC-realizes $\\mathcal{F}_\\textsf{LeakyMult}$. We are considering the protocol accessing to the functionality $\\mathcal{F}_\\textsf{2PC-Mult}$, but replacing it with $\\mathcal{F}_\\textsf{2PC-WeakMult}$ is done in a natural way.\nFinally, we present the protocol that realizes the functionality $\\mathcal{F}_\\textsf{PedMultEqTest}$. As we mentioned earlier, this protocol is key for checking the correctness of multiplications in the overall protocol.\nAlthough the protocol presented here is the main version of the Threshold ECDSA protocol, Lindell et al. present multiple improvements to reduce the number of rounds needed to generate keys and compute signatures. These improvements can be found in Sections 3.5 and 4.5.\nSecurity concerns #   In general, the protocol specification in this work has some notation issues and typos. Although a careful reading of the paper may reveal these errors, they may cause also implementation errors by software developers who are not experts in cryptography. We corrected those typos in this document and the corrections were marked in red inside the text. The protocol assumes an authenticated point-to-point channel between parties. Therefore we must ensure that the channels fulfill this property. The protocol assumes that the environment provides a fresh session ID on each invocation it makes. To do this the parties need to choose a fresh session ID which can be computed using a single round coin-flipping protocol. Such protocol consists of the parties sending uniform strings to each other and the session ID is set to be the hash of their concatenation. The protocol assumes that all the honest parties agree on the common input. Such an agreement can be made by letting the parties send a hash of their common input in the first round of each protocol and its sub-protocols. In both the key generation and the signing protocol, they make calls to the protocol for zero-knowledge functionalities. The parties should verify that the session ID and the instance it receives for the zero-knowledge protocol are consistent with the common input of the previous steps of the protocol in which the zero-knowledge is being executed. In the non-threshold protocol, it is important to consider as public view all the elements that the paper lists in each verification step. Missing an execution of $\\mathcal{F}_\\textsf{PedMultEqTest}$ in the protocol $\\textsf{ManyPartyLeakyMult}$ could end in a wrong multiplication with catastrophic results due to the high possibility of an adversarial behavior.  ZK-proofs and commitments #  For the signing protocol #  In the signing protocol, Step 3, the parties engage in two $\\textsf{CreateSharedVals}$ protocols that create a Pedersen commitment of a uniformly chosen value.\nFor $\\textsf{CreateSharedVals}$ #   In Step 1, each party $P_i$ creates a Pedersen commitment of $a_i$. In Step 2, each party $P_i$ sends a ZK-proof on the tuple $(\\textsf{sid}, (D, \\hat{A}_i), (a_i, r_i))$ according to the relation $\\mathcal{R}_{\\textsf{PedKlwg}}$.  For $\\textsf{OutSharedVal}$ #  In Step 2 of the protocol, parties execute a ZK-proof to test that $\\hat{A}_i$ is the Pedersen commitment of $a_i$.\nFor $\\textsf{OutExpOfSharedVal}$ #  In Step 2, parties execute a ZK-proof to test that $\\hat{A}_i$ is the commitment of $a_i$ and that $a_i$ is the exponent of $A_i$.\nFor the Key Generation #   In Step 2(c) the party $P_i$ sends Pedersen commitments of $c_{i,j}$ to all parties. In Step 2(e)(i) the party $P_i$ sends Pedersen commitments of $p_i(\\alpha)$ to all parties. In Step 2(e)(ii) the party $P_i$ engage in a ZK-proof to proof that $r^Y_{i, \\alpha} - \\sum_j r^C_{i,j} \\cdot \\alpha_j$ is the discrete logarithm of $\\hat{D}_{i,\\alpha} - \\hat{B}_{i, \\alpha}$  For $\\textsf{ManyPartyLeakyMult}$ #   In Step 2, the party $P_i$ prooves knowledge that he has $a_i$ for which $\\hat{A}_i$ is a Pedersen commitment, and that he has $b_i$ for which $\\hat{B}_i$ is a Pedersen commitment. In Step 3(a), the party $P_i$ sends a Pedersen commitment of $c_i$ to all parties. In Step 3(b), the party $P_i$ proves knowledge of $c_i$ for which $\\hat{C}_i$ is its Pedersen commitment. In Step 4, the party $P_i$ verify that $\\sum \\hat{C}_l$ is a commitment of $(\\sum a_i) \\cdot (\\sum b_i)$.  For $\\textsf{PedMultEqTest}$ #   In Step 1(a), the party $P_i$ proves in zero-knowledge that he has the discrete logarithm of $E_i$. In Step 2(a), the party $P_i$ computes an ElGamal commitment of $x_i$. In Step 2(b), the party $P_i$ proves in zero-knowledge that he has $x_i$ for which it holds that both $\\hat{X}_i$ is its Pedersen commitment and $\\tilde{X}_i$ is its ElGamal commitment. In Step 3(b), the party $P_i$ rerandomizes the commitment of $a_i \\cdot \\tilde{B}$ In Step 3(c), the party $P_i$ proves in zero-knowledge that $((E, \\tilde{B}, \\tilde{A}_i, \\tilde{F}_i), (r^{\\tilde{A}}_i, r_i^F, a_i))$ belongs to the relation $\\mathcal{R}_\\textsf{EgProdEg}$. In Step 4(b), the party $P_i$ proves in zero-knowledge that he knows a constant $o_i$ such that $\\tilde{Z}_i$ is the commitment of the value of commited in $\\tilde{Y}$ multiplied by $o_i$. In Step 5(b), the party $P_i$ proves in zero-knowledge that the tuple $((G, \\tilde{Z}_L), (E_i, W_i), e_i)$ belongs to the relation $\\mathcal{R}_\\textsf{DH}$.  References #   Lindell, Y., \u0026amp; Nof, A. (2018). Fast Secure Multiparty ECDSA with Practical Distributed Key Generation and Applications to Cryptocurrency Custody. Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security, 1837–1854. https://doi.org/10.1145/3243734.3243788 Haitner, I., Makriyannis, N., Ranellucci, S., \u0026amp; Tsfadia, E. (2022). Highly Efficient OT-Based Multiplication Protocols. In O. Dunkelman \u0026amp; S. Dziembowski (Eds.), Advances in Cryptology – EUROCRYPT 2022 (pp. 180–209). Springer International Publishing. Pedersen, T. P. (1992). Non-interactive and Information-Theoretic Secure Verifiable Secret Sharing. In J. Feigenbaum (Ed.), Advances in Cryptology — CRYPTO ’91 (pp. 129–140). Springer Berlin Heidelberg.  "}]